/* tslint:disable */
/* eslint-disable */
/**
 * Libre Graph API
 * Libre Graph is a free API for cloud collaboration inspired by the MS Graph API.
 *
 * The version of the OpenAPI document: v1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents activity.
 */
export interface Activity {
    /**
     * Activity ID.
     */
    'id': string;
    'times': ActivityTimes;
    'template': ActivityTemplate;
}
export interface ActivityTemplate {
    /**
     * Activity description.
     */
    'message': string;
    /**
     * Activity description variables.
     */
    'variables'?: object;
}
export interface ActivityTimes {
    /**
     * Timestamp of the activity.
     */
    'recordedTime': string;
}
export interface AppRole {
    /**
     * Specifies whether this app role can be assigned to users and groups (by setting to [\'User\']), to other application\'s (by setting to [\'Application\'], or both (by setting to [\'User\', \'Application\']). App roles supporting assignment to other applications\' service principals are also known as application permissions. The \'Application\' value is only supported for app roles defined on application entities.
     */
    'allowedMemberTypes'?: Array<string>;
    /**
     * The description for the app role. This is displayed when the app role is being assigned and, if the app role functions as an application permission, during  consent experiences.
     */
    'description'?: string | null;
    /**
     * Display name for the permission that appears in the app role assignment and consent experiences.
     */
    'displayName'?: string | null;
    /**
     * Unique role identifier inside the appRoles collection. When creating a new app role, a new GUID identifier must be provided.
     */
    'id': string;
}
export interface AppRoleAssignment {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     */
    'id'?: string;
    'deletedDateTime'?: string;
    /**
     * The identifier (id) for the app role which is assigned to the user. Required on create.
     */
    'appRoleId': string;
    /**
     * The time when the app role assignment was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    'createdDateTime'?: string | null;
    /**
     * The display name of the user, group, or service principal that was granted the app role assignment. Read-only.
     */
    'principalDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the user, security group, or service principal being granted the app role. Security groups with dynamic memberships are supported. Required on create.
     */
    'principalId': string | null;
    /**
     * The type of the assigned principal. This can either be User, Group, or ServicePrincipal. Read-only.
     */
    'principalType'?: string | null;
    /**
     * The display name of the resource app\'s service principal to which the assignment is made.
     */
    'resourceDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the resource service principal for which the assignment is made. Required on create.
     */
    'resourceId': string | null;
}
export interface Application {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     */
    'id': string;
    /**
     * The collection of roles defined for the application. With app role assignments, these roles can be assigned to users, groups, or service principals associated with other applications. Not nullable.
     */
    'appRoles'?: Array<AppRole>;
    /**
     * The display name for the application.
     */
    'displayName'?: string | null;
}
/**
 * The Audio resource groups audio-related properties on an item into a single structure.  If a DriveItem has a non-null audio facet, the item represents an audio file. The properties of the Audio resource are populated by extracting metadata from the file. 
 */
export interface Audio {
    /**
     * The title of the album for this audio file.
     */
    'album'?: string;
    /**
     * The artist named on the album for the audio file.
     */
    'albumArtist'?: string;
    /**
     * The performing artist for the audio file.
     */
    'artist'?: string;
    /**
     * Bitrate expressed in kbps.
     */
    'bitrate'?: number;
    /**
     * The name of the composer of the audio file.
     */
    'composers'?: string;
    /**
     * Copyright information for the audio file.
     */
    'copyright'?: string;
    /**
     * The number of the disc this audio file came from.
     */
    'disc'?: number;
    /**
     * The total number of discs in this album.
     */
    'discCount'?: number;
    /**
     * Duration of the audio file, expressed in milliseconds
     */
    'duration'?: number;
    /**
     * The genre of this audio file.
     */
    'genre'?: string;
    /**
     * Indicates if the file is protected with digital rights management.
     */
    'hasDrm'?: boolean;
    /**
     * Indicates if the file is encoded with a variable bitrate.
     */
    'isVariableBitrate'?: boolean;
    /**
     * The title of the audio file.
     */
    'title'?: string;
    /**
     * The number of the track on the original disc for this audio file.
     */
    'track'?: number;
    /**
     * The total number of tracks on the original disc for this audio file.
     */
    'trackCount'?: number;
    /**
     * The year the audio file was recorded.
     */
    'year'?: number;
}
export interface ClassMemberReference {
    '@odata.id'?: string;
}
export interface ClassReference {
    '@odata.id'?: string;
}
export interface ClassTeacherReference {
    '@odata.id'?: string;
}
export interface CollectionOfActivities {
    'value'?: Array<Activity>;
}
export interface CollectionOfAppRoleAssignments {
    'value'?: Array<AppRoleAssignment>;
    '@odata.nextLink'?: string;
}
export interface CollectionOfApplications {
    'value'?: Array<Application>;
}
export interface CollectionOfClass {
    'value'?: Array<EducationClass>;
}
export interface CollectionOfDriveItems {
    'value'?: Array<DriveItem>;
    '@odata.nextLink'?: string;
}
export interface CollectionOfDriveItems1 {
    'value'?: Array<DriveItem>;
}
export interface CollectionOfDrives {
    'value'?: Array<Drive>;
    '@odata.nextLink'?: string;
}
export interface CollectionOfDrives1 {
    'value'?: Array<Drive>;
}
export interface CollectionOfEducationClass {
    'value'?: Array<EducationClass>;
}
export interface CollectionOfEducationUser {
    'value'?: Array<EducationUser>;
}
export interface CollectionOfGroup {
    'value'?: Array<Group>;
    '@odata.nextLink'?: string;
}
export interface CollectionOfPermissions {
    'value'?: Array<Permission>;
}
export interface CollectionOfPermissionsWithAllowedValues {
    /**
     * A list of role definitions that can be chosen for the resource.
     */
    '@libre.graph.permissions.roles.allowedValues'?: Array<UnifiedRoleDefinition>;
    /**
     * A list of actions that can be chosen for a custom role.  Following the CS3 API we can represent the CS3 permissions by mapping them to driveItem properties or relations like this: | [CS3 ResourcePermission](https://cs3org.github.io/cs3apis/#cs3.storage.provider.v1beta1.ResourcePermissions) | action | comment | | ------------------------------------------------------------------------------------------------------------ | ------ | ------- | | `stat` | `libre.graph/driveItem/basic/read` | `basic` because it does not include versions or trashed items | | `get_quota` | `libre.graph/driveItem/quota/read` | read only the `quota` property | | `get_path` | `libre.graph/driveItem/path/read` | read only the `path` property | | `move` | `libre.graph/driveItem/path/update` | allows updating the `path` property of a CS3 resource | | `delete` | `libre.graph/driveItem/standard/delete` | `standard` because deleting is a common update operation | | `list_container` | `libre.graph/driveItem/children/read` | | | `create_container` | `libre.graph/driveItem/children/create` | | | `initiate_file_download` | `libre.graph/driveItem/content/read` | `content` is the property read when initiating a download | | `initiate_file_upload` | `libre.graph/driveItem/upload/create` | `uploads` are a separate property. postprocessing creates the `content` | | `add_grant` | `libre.graph/driveItem/permissions/create` | | | `list_grant` | `libre.graph/driveItem/permissions/read` | | | `update_grant` | `libre.graph/driveItem/permissions/update` | | | `remove_grant` | `libre.graph/driveItem/permissions/delete` | | | `deny_grant` | `libre.graph/driveItem/permissions/deny` | uses a non CRUD action `deny` | | `list_file_versions` | `libre.graph/driveItem/versions/read` | `versions` is a `driveItemVersion` collection | | `restore_file_version` | `libre.graph/driveItem/versions/update` | the only `update` action is restore | | `list_recycle` | `libre.graph/driveItem/deleted/read` | reading a driveItem `deleted` property implies listing | | `restore_recycle_item` | `libre.graph/driveItem/deleted/update` | the only `update` action is restore | | `purge_recycle` | `libre.graph/driveItem/deleted/delete` | allows purging deleted `driveItems` | 
     */
    '@libre.graph.permissions.actions.allowedValues'?: Array<string>;
    'value'?: Array<Permission>;
}
export interface CollectionOfSchools {
    'value'?: Array<EducationSchool>;
}
export interface CollectionOfTags {
    'value'?: Array<string>;
}
export interface CollectionOfUser {
    'value'?: Array<User>;
    '@odata.nextLink'?: string;
}
export interface CollectionOfUsers {
    'value'?: Array<User>;
}
/**
 * Information about the deleted state of the item. Read-only.
 */
export interface Deleted {
    /**
     * Represents the state of the deleted item.
     */
    'state'?: string;
}
/**
 * The drive represents a space on the storage.
 */
export interface Drive {
    /**
     * The unique identifier for this drive.
     */
    'id'?: string;
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     */
    'eTag'?: string;
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     */
    'name': string;
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     */
    'webUrl'?: string;
    /**
     * Describes the type of drive represented by this resource. Values are \"personal\" for users home spaces, \"project\", \"virtual\" or \"share\". Read-only.
     */
    'driveType'?: string;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     */
    'driveAlias'?: string;
    'owner'?: IdentitySet;
    'quota'?: Quota;
    /**
     * All items contained in the drive. Read-only. Nullable.
     */
    'items'?: Array<DriveItem>;
    'root'?: DriveItem;
    /**
     * A collection of special drive resources.
     */
    'special'?: Array<DriveItem>;
}
/**
 * Represents a resource inside a drive. Read-only.
 */
export interface DriveItem {
    /**
     * Read-only.
     */
    'id'?: string;
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     */
    'eTag'?: string;
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     */
    'name'?: string;
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     */
    'webUrl'?: string;
    /**
     * The content stream, if the item represents a file.
     */
    'content'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     */
    'cTag'?: string;
    'deleted'?: Deleted;
    'file'?: OpenGraphFile;
    'fileSystemInfo'?: FileSystemInfo;
    'folder'?: Folder;
    'image'?: Image;
    'photo'?: Photo;
    'location'?: GeoCoordinates;
    /**
     * Collection containing ThumbnailSet objects associated with the item. Read-only. Nullable.
     */
    'thumbnails'?: Array<ThumbnailSet>;
    /**
     * If this property is non-null, it indicates that the driveItem is the top-most driveItem in the drive.
     */
    'root'?: object;
    'trash'?: Trash;
    'specialFolder'?: SpecialFolder;
    'remoteItem'?: RemoteItem;
    /**
     * Size of the item in bytes. Read-only.
     */
    'size'?: number;
    /**
     * WebDAV compatible URL for the item. Read-only.
     */
    'webDavUrl'?: string;
    /**
     * Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.
     */
    'children'?: Array<DriveItem>;
    /**
     * The set of permissions for the item. Read-only. Nullable.
     */
    'permissions'?: Array<Permission>;
    'audio'?: Audio;
    'video'?: Video;
    /**
     * Indicates if the item is synchronized with the underlying storage provider. Read-only.
     */
    '@client.synchronize'?: boolean;
    /**
     * Properties or facets (see UI.Facet) annotated with this term will not be rendered if the annotation evaluates to true. Users can set this to hide permissions.
     */
    '@UI.Hidden'?: boolean;
}
export interface DriveItemCreateLink {
    'type'?: SharingLinkType;
    /**
     * Optional. A String with format of yyyy-MM-ddTHH:mm:ssZ of DateTime indicates the expiration time of the permission.
     */
    'expirationDateTime'?: string;
    /**
     * Optional.The password of the sharing link that is set by the creator.
     */
    'password'?: string;
    /**
     * Provides a user-visible display name of the link. Optional. Libregraph only.
     */
    'displayName'?: string;
    /**
     * The quicklink property can be assigned to only one link per resource. A quicklink can be used in the clients to provide a one-click copy to clipboard action. Optional. Libregraph only.
     */
    '@libre.graph.quickLink'?: boolean;
}


export interface DriveItemInvite {
    /**
     * A collection of recipients who will receive access and the sharing invitation. Currently, only internal users or groups are supported.
     */
    'recipients'?: Array<DriveRecipient>;
    /**
     * Specifies the roles that are to be granted to the recipients of the sharing invitation.
     */
    'roles'?: Array<string>;
    /**
     * Specifies the actions that are to be granted to the recipients of the sharing invitation, in effect creating a custom role.
     */
    '@libre.graph.permissions.actions'?: Array<string>;
    /**
     * Specifies the dateTime after which the permission expires.
     */
    'expirationDateTime'?: string;
}
/**
 * Represents a person, group, or other recipient to share a drive item with using the invite action.  When using invite to add permissions, the `driveRecipient` object would specify the `email`, `alias`, or `objectId` of the recipient. Only one of these values is required; multiple values are not accepted. 
 */
export interface DriveRecipient {
    /**
     * The unique identifier for the recipient in the directory.
     */
    'objectId'?: string;
    /**
     * When the recipient is referenced by objectId this annotation is used to differentiate `user` and `group` recipients.
     */
    '@libre.graph.recipient.type'?: string;
}
/**
 * The drive represents an update to a space on the storage.
 */
export interface DriveUpdate {
    /**
     * The unique identifier for this drive.
     */
    'id'?: string;
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     */
    'eTag'?: string;
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     */
    'name'?: string;
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     */
    'webUrl'?: string;
    /**
     * Describes the type of drive represented by this resource. Values are \"personal\" for users home spaces, \"project\", \"virtual\" or \"share\". Read-only.
     */
    'driveType'?: string;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     */
    'driveAlias'?: string;
    'owner'?: IdentitySet;
    'quota'?: Quota;
    /**
     * All items contained in the drive. Read-only. Nullable.
     */
    'items'?: Array<DriveItem>;
    'root'?: DriveItem;
    /**
     * A collection of special drive resources.
     */
    'special'?: Array<DriveItem>;
}
/**
 * And extension of group representing a class or course
 */
export interface EducationClass {
    /**
     * Read-only.
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     */
    'displayName'?: string;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     */
    'members@odata.bind'?: Set<string>;
    /**
     * Classification of the group, i.e. \"class\" or \"course\"
     */
    'classification'?: EducationClassClassificationEnum;
    /**
     * An external unique ID for the class
     */
    'externalId'?: string;
}

export const EducationClassClassificationEnum = {
    Class: 'class',
    Course: 'course'
} as const;

export type EducationClassClassificationEnum = typeof EducationClassClassificationEnum[keyof typeof EducationClassClassificationEnum];

/**
 * Represents a school
 */
export interface EducationSchool {
    /**
     * The unique identifier for an entity. Read-only.
     */
    'id'?: string;
    /**
     * The organization name
     */
    'displayName'?: string;
    /**
     * School number
     */
    'schoolNumber'?: string;
    /**
     * Date and time at which the service for this organization is scheduled to be terminated
     */
    'terminationDate'?: string | null;
}
/**
 * An extension of user with education-specific attributes
 */
export interface EducationUser {
    /**
     * Read-only.
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     */
    'accountEnabled'?: boolean;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     */
    'drives'?: Array<Drive>;
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory. Read-only.
     */
    'onPremisesSamAccountName'?: string;
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     */
    'givenName'?: string;
    /**
     * The user`s default role. Such as \"student\" or \"teacher\"
     */
    'primaryRole'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, \"Guest\" for guest users or \"Federated\" for users imported from a federated instance.
     */
    'userType'?: string;
    /**
     * A unique identifier for the user assigned by the school or institution.
     */
    'externalID'?: string;
}
export interface EducationUserReference {
    '@odata.id'?: string;
}
export interface ExportPersonalDataRequest {
    /**
     * the path where the file should be created in the users personal space
     */
    'storageLocation'?: string;
}
/**
 * File system information on client. Read-write.
 */
export interface FileSystemInfo {
    /**
     * The UTC date and time the file was created on a client.
     */
    'createdDateTime'?: string;
    /**
     * The UTC date and time the file was last accessed. Available for the recent file list only.
     */
    'lastAccessedDateTime'?: string;
    /**
     * The UTC date and time the file was last modified on a client.
     */
    'lastModifiedDateTime'?: string;
}
/**
 * Folder metadata, if the item is a folder. Read-only.
 */
export interface Folder {
    /**
     * Number of children contained immediately within this container.
     */
    'childCount'?: number;
    'view'?: FolderView;
}
/**
 * A collection of properties defining the recommended view for the folder.
 */
export interface FolderView {
    /**
     * The method by which the folder should be sorted.
     */
    'sortBy'?: string;
    /**
     * If true, indicates that items should be sorted in descending order. Otherwise, items should be sorted ascending.
     */
    'sortOrder'?: string;
    /**
     * The type of view that should be used to represent the folder.
     */
    'viewType'?: string;
}
/**
 * The GeoCoordinates resource provides geographic coordinates and elevation of a location based on metadata contained within the file. If a DriveItem has a non-null location facet, the item represents a file with a known location associated with it. 
 */
export interface GeoCoordinates {
    /**
     * The altitude (height), in feet, above sea level for the item. Read-only.
     */
    'altitude'?: number;
    /**
     * The latitude, in decimal, for the item. Read-only.
     */
    'latitude'?: number;
    /**
     * The longitude, in decimal, for the item. Read-only.
     */
    'longitude'?: number;
}
export interface Group {
    /**
     * Read-only.
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     */
    'displayName'?: string;
    /**
     * Specifies the group types. In MS Graph a group can have multiple types, so this is an array. In libreGraph the possible group types deviate from the MS Graph. The only group type that we currently support is \"ReadOnly\", which is set for groups that cannot be modified on the current instance.
     */
    'groupTypes'?: Array<string>;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     */
    'members@odata.bind'?: Set<string>;
}
/**
 * Hashes of the file\'s binary content, if available. Read-only.
 */
export interface Hashes {
    /**
     * The CRC32 value of the file (if available). Read-only.
     */
    'crc32Hash'?: string;
    /**
     * A proprietary hash of the file that can be used to determine if the contents of the file have changed (if available). Read-only.
     */
    'quickXorHash'?: string;
    /**
     * SHA1 hash for the contents of the file (if available). Read-only.
     */
    'sha1Hash'?: string;
    /**
     * SHA256 hash for the contents of the file (if available). Read-only.
     */
    'sha256Hash'?: string;
}
export interface Identity {
    /**
     * The identity\'s display name. Note that this may not always be available or up to date. For example, if a user changes their display name, the API may show the new value in a future response, but the items associated with the user won\'t show up as having changed when using delta.
     */
    'displayName': string;
    /**
     * Unique identifier for the identity.
     */
    'id'?: string;
    /**
     * The type of the identity. This can be either \"Member\" for regular user, \"Guest\" for guest users or \"Federated\" for users imported from a federated instance. Can be used by clients to indicate the type of user. For more details, clients should look up and cache the user at the /users endpoint.
     */
    '@libre.graph.userType'?: string;
}
/**
 * Optional. User account.
 */
export interface IdentitySet {
    'application'?: Identity;
    'device'?: Identity;
    'user'?: Identity;
    'group'?: Identity;
}
/**
 * Image metadata, if the item is an image. Read-only.
 */
export interface Image {
    /**
     * Optional. Height of the image, in pixels. Read-only.
     */
    'height'?: number;
    /**
     * Optional. Width of the image, in pixels. Read-only.
     */
    'width'?: number;
}
/**
 * An oCIS instance that the user is either a member or a guest of.
 */
export interface Instance {
    /**
     * The URL of the oCIS instance.
     */
    'url'?: string;
    /**
     * Whether the instance is the user\'s primary instance.
     */
    'primary'?: boolean;
}
export interface ItemReference {
    /**
     * Unique identifier of the drive instance that contains the item. Read-only.
     */
    'driveId'?: string;
    /**
     * Identifies the type of drive. See [drive][] resource for values. Read-only.
     */
    'driveType'?: string;
    /**
     * Unique identifier of the item in the drive. Read-only.
     */
    'id'?: string;
    /**
     * The name of the item being referenced. Read-only.
     */
    'name'?: string;
    /**
     * Path that can be used to navigate to the item. Read-only.
     */
    'path'?: string;
}
export interface MemberReference {
    '@odata.id'?: string;
}
/**
 * Represents an identity used to sign in to a user account
 */
export interface ObjectIdentity {
    /**
     * domain of the Provider issuing the identity
     */
    'issuer'?: string;
    /**
     * The unique id assigned by the issuer to the account
     */
    'issuerAssignedId'?: string;
}
export interface OdataError {
    'error': OdataErrorMain;
}
export interface OdataErrorDetail {
    'code': string;
    'message': string;
    'target'?: string;
}
export interface OdataErrorMain {
    'code': string;
    'message': string;
    'target'?: string;
    'details'?: Array<OdataErrorDetail>;
    /**
     * The structure of this object is service-specific
     */
    'innererror'?: object;
}
/**
 * File metadata, if the item is a file. Read-only.
 */
export interface OpenGraphFile {
    'hashes'?: Hashes;
    /**
     * The MIME type for the file. This is determined by logic on the server and might not be the value provided when the file was uploaded. Read-only.
     */
    'mimeType'?: string;
    'processingMetadata'?: boolean;
}
export interface PasswordChange {
    'currentPassword': string;
    'newPassword': string;
}
/**
 * Password Profile associated with a user
 */
export interface PasswordProfile {
    /**
     * If true the user is required to change their password upon the next login
     */
    'forceChangePasswordNextSignIn'?: boolean;
    /**
     * The user\'s password
     */
    'password'?: string;
}
/**
 * The Permission resource provides information about a sharing permission granted for a DriveItem resource.  ### Remarks  The Permission resource uses *facets* to provide information about the kind of permission represented by the resource.  Permissions with a `link` facet represent sharing links created on the item. Sharing links contain a unique token that provides access to the item for anyone with the link.  Permissions with a `invitation` facet represent permissions added by inviting specific users or groups to have access to the file. 
 */
export interface Permission {
    /**
     * The unique identifier of the permission among all permissions on the item. Read-only.
     */
    'id'?: string;
    /**
     * Indicates whether the password is set for this permission. This property only appears in the response. Optional. Read-only. 
     */
    'hasPassword'?: boolean;
    /**
     * An optional expiration date which limits the permission in time.
     */
    'expirationDateTime'?: string | null;
    /**
     * An optional creation date. Libregraph only.
     */
    'createdDateTime'?: string | null;
    'grantedToV2'?: SharePointIdentitySet;
    'link'?: SharingLink;
    'roles'?: Array<string>;
    /**
     * For link type permissions, the details of the identity to whom permission was granted. This could be used to grant access to a an external user that can be identified by email, aka guest accounts.
     * @deprecated
     */
    'grantedToIdentities'?: Array<IdentitySet>;
    /**
     * Use this to create a permission with custom actions.
     */
    '@libre.graph.permissions.actions'?: Array<string>;
    'invitation'?: SharingInvitation;
}
/**
 * The photo resource provides photo and camera properties, for example, EXIF metadata, on a driveItem. 
 */
export interface Photo {
    /**
     * Camera manufacturer. Read-only.
     */
    'cameraMake'?: string;
    /**
     * Camera model. Read-only.
     */
    'cameraModel'?: string;
    /**
     * The denominator for the exposure time fraction from the camera. Read-only.
     */
    'exposureDenominator'?: number;
    /**
     * The numerator for the exposure time fraction from the camera. Read-only.
     */
    'exposureNumerator'?: number;
    /**
     * The F-stop value from the camera. Read-only.
     */
    'fNumber'?: number;
    /**
     * The focal length from the camera. Read-only.
     */
    'focalLength'?: number;
    /**
     * The ISO value from the camera. Read-only.
     */
    'iso'?: number;
    /**
     * The orientation value from the camera. Read-only.
     */
    'orientation'?: number;
    /**
     * Represents the date and time the photo was taken. Read-only.
     */
    'takenDateTime'?: string;
}
/**
 * Optional. Information about the drive\'s storage space quota. Read-only.
 */
export interface Quota {
    /**
     * Total space consumed by files in the recycle bin, in bytes. Read-only.
     */
    'deleted'?: number;
    /**
     * Total space remaining before reaching the quota limit, in bytes. Read-only.
     */
    'remaining'?: number;
    /**
     * Enumeration value that indicates the state of the storage space. Either \"normal\", \"nearing\", \"critical\" or \"exceeded\". Read-only.
     */
    'state'?: string;
    /**
     * Total allowed storage space, in bytes. Read-only.
     */
    'total'?: number;
    /**
     * Total space used, in bytes. Read-only.
     */
    'used'?: number;
}
/**
 * Remote item data, if the item is shared from a drive other than the one being accessed. Read-only.
 */
export interface RemoteItem {
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     */
    'createdDateTime'?: string;
    'file'?: OpenGraphFile;
    'fileSystemInfo'?: FileSystemInfo;
    'folder'?: Folder;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     */
    'driveAlias'?: string;
    /**
     * The relative path of the item in relation to its drive root.
     */
    'path'?: string;
    /**
     * Unique identifier for the drive root of this item. Read-only.
     */
    'rootId'?: string;
    /**
     * Unique identifier for the remote item in its drive. Read-only.
     */
    'id'?: string;
    'image'?: Image;
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     */
    'lastModifiedDateTime'?: string;
    /**
     * Optional. Filename of the remote item. Read-only.
     */
    'name'?: string;
    /**
     * ETag for the item. Read-only.
     */
    'eTag'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     */
    'cTag'?: string;
    'parentReference'?: ItemReference;
    /**
     * The set of permissions for the item. Read-only. Nullable.
     */
    'permissions'?: Array<Permission>;
    /**
     * Size of the remote item. Read-only.
     */
    'size'?: number;
    'specialFolder'?: SpecialFolder;
    /**
     * DAV compatible URL for the item.
     */
    'webDavUrl'?: string;
    /**
     * URL that displays the resource in the browser. Read-only.
     */
    'webUrl'?: string;
    /**
     * The UUID of the space that contains the item.
     */
    'spaceId'?: string;
}
/**
 * This resource is used to represent a set of identities associated with various events for an item, such as created by or last modified by.
 */
export interface SharePointIdentitySet {
    'user'?: Identity;
    'group'?: Identity;
}
/**
 * invitation-related data items 
 */
export interface SharingInvitation {
    'invitedBy'?: IdentitySet;
}
/**
 * The `SharingLink` resource groups link-related data items into a single structure.  If a `permission` resource has a non-null `sharingLink` facet, the permission represents a sharing link (as opposed to permissions granted to a person or group). 
 */
export interface SharingLink {
    'type'?: SharingLinkType;
    /**
     * If `true` then the user can only use this link to view the item on the web, and cannot use it to download the contents of the item.
     */
    'preventsDownload'?: boolean;
    /**
     * A URL that opens the item in the browser on the website.
     */
    'webUrl'?: string;
    /**
     * Provides a user-visible display name of the link. Optional. Libregraph only.
     */
    '@libre.graph.displayName'?: string;
    /**
     * The quicklink property can be assigned to only one link per resource. A quicklink can be used in the clients to provide a one-click copy to clipboard action. Optional. Libregraph only.
     */
    '@libre.graph.quickLink'?: boolean;
}


/**
 * The sharing link password which should be set. 
 */
export interface SharingLinkPassword {
    /**
     * Password. It may require a password policy.
     */
    'password'?: string;
}
/**
 * The type of the link created.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | internal       | Internal          | Creates an internal link without any permissions.               | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
 */

export const SharingLinkType = {
    Internal: 'internal',
    View: 'view',
    Upload: 'upload',
    Edit: 'edit',
    CreateOnly: 'createOnly',
    BlocksDownload: 'blocksDownload'
} as const;

export type SharingLinkType = typeof SharingLinkType[keyof typeof SharingLinkType];


/**
 * Provides the last successful sign-in attempt for a user
 */
export interface SignInActivity {
    /**
     * The date and time of the last successful sign-in for the user.
     */
    'lastSuccessfulSignInDateTime'?: string;
}
/**
 * If the current item is also available as a special folder, this facet is returned. Read-only
 */
export interface SpecialFolder {
    /**
     * The unique identifier for this item in the /drive/special collection
     */
    'name'?: string;
}
export interface TagAssignment {
    'resourceId': string;
    'tags': Array<string>;
}
export interface TagUnassignment {
    'resourceId': string;
    'tags': Array<string>;
}
/**
 * The thumbnail resource type represents a thumbnail for an image, video, document, or any item that has a bitmap representation. 
 */
export interface Thumbnail {
    /**
     * The content stream for the thumbnail.
     */
    'content'?: string;
    /**
     * The height of the thumbnail, in pixels.
     */
    'height'?: number;
    /**
     * The unique identifier of the item that provided the thumbnail. This is only available when a folder thumbnail is requested.
     */
    'sourceItemId'?: string;
    /**
     * The URL used to fetch the thumbnail content.
     */
    'url'?: string;
    /**
     * The width of the thumbnail, in pixels.
     */
    'width'?: number;
}
/**
 * The ThumbnailSet resource is a keyed collection of thumbnail resources. It\'s used to represent a set of thumbnails associated with a DriveItem. 
 */
export interface ThumbnailSet {
    /**
     * The ID within the item. Read-only.
     */
    'id'?: string;
    'large'?: Thumbnail;
    'medium'?: Thumbnail;
    'small'?: Thumbnail;
    'source'?: Thumbnail;
}
/**
 * Metadata for trashed drive Items
 */
export interface Trash {
    'trashedBy'?: IdentitySet;
    /**
     * The UTC date and time the folder was marked as trashed.
     */
    'trashedDateTime'?: string;
}
/**
 * A role definition is a collection of permissions in libre graph listing the operations that can be performed and the resources against which they can performed. 
 */
export interface UnifiedRoleDefinition {
    /**
     * The description for the unifiedRoleDefinition.
     */
    'description'?: string;
    /**
     * The display name for the unifiedRoleDefinition. Required. Supports $filter (`eq`, `in`).
     */
    'displayName'?: string;
    /**
     * The unique identifier for the role definition. Key, not nullable, Read-only. Inherited from entity. Supports $filter (`eq`, `in`).
     */
    'id'?: string;
    /**
     * List of permissions included in the role.
     */
    'rolePermissions'?: Array<UnifiedRolePermission>;
    /**
     * When presenting a list of roles the weight can be used to order them in a meaningful way. Lower weight gets higher precedence. So content with lower weight will come first. If set, weights should be non-zero, as 0 is interpreted as an unset weight. 
     */
    '@libre.graph.weight'?: number;
}
/**
 * Represents a collection of allowed resource actions and the conditions that must be met for the action to be allowed. Resource actions are tasks that can be performed on a resource. For example, an application resource may support create, update, delete, and reset password actions. 
 */
export interface UnifiedRolePermission {
    /**
     * Set of tasks that can be performed on a resource. Required.  The following is the schema for resource actions:  ```    {Namespace}/{Entity}/{PropertySet}/{Action} ```   For example: `libre.graph/applications/credentials/update`   * *{Namespace}* - The services that exposes the task. For example, all tasks in libre graph use the namespace `libre.graph`.  * *{Entity}* - The logical features or components exposed by the service in libre graph. For example, `applications`, `servicePrincipals`, or `groups`.  * *{PropertySet}* - Optional. The specific properties or aspects of the entity for which access is being granted.    For example, `libre.graph/applications/authentication/read` grants the ability to read the reply URL, logout URL,    and implicit flow property on the **application** object in libre graph. The following are reserved names for common property sets:    * `allProperties` - Designates all properties of the entity, including privileged properties.      Examples include `libre.graph/applications/allProperties/read` and `libre.graph/applications/allProperties/update`.    * `basic` - Designates common read properties but excludes privileged ones.      For example, `libre.graph/applications/basic/update` includes the ability to update standard properties like display name.    * `standard` - Designates common update properties but excludes privileged ones.      For example, `libre.graph/applications/standard/read`.  * *{Actions}* - The operations being granted. In most circumstances, permissions should be expressed in terms of CRUD operations or allTasks. Actions include:    * `create` - The ability to create a new instance of the entity.    * `read` - The ability to read a given property set (including allProperties).    * `update` - The ability to update a given property set (including allProperties).    * `delete` - The ability to delete a given entity.    * `allTasks` - Represents all CRUD operations (create, read, update, and delete).   Following the CS3 API we can represent the CS3 permissions by mapping them to driveItem properties or relations like this:  | [CS3 ResourcePermission](https://cs3org.github.io/cs3apis/#cs3.storage.provider.v1beta1.ResourcePermissions) | action | comment |  | ------------------------------------------------------------------------------------------------------------ | ------ | ------- |  | `stat` | `libre.graph/driveItem/basic/read` | `basic` because it does not include versions or trashed items |  | `get_quota` | `libre.graph/driveItem/quota/read` | read only the `quota` property |  | `get_path` | `libre.graph/driveItem/path/read` | read only the `path` property |  | `move` | `libre.graph/driveItem/path/update` | allows updating the `path` property of a CS3 resource |  | `delete` | `libre.graph/driveItem/standard/delete` | `standard` because deleting is a common update operation |  | `list_container` | `libre.graph/driveItem/children/read` | |  | `create_container` | `libre.graph/driveItem/children/create` | |  | `initiate_file_download` | `libre.graph/driveItem/content/read` | `content` is the property read when initiating a download |  | `initiate_file_upload` | `libre.graph/driveItem/upload/create` | `uploads` are a separate property. postprocessing creates the `content` |  | `add_grant` | `libre.graph/driveItem/permissions/create` | |  | `list_grant` | `libre.graph/driveItem/permissions/read` | |  | `update_grant` | `libre.graph/driveItem/permissions/update` | |  | `remove_grant` | `libre.graph/driveItem/permissions/delete` | |  | `deny_grant` | `libre.graph/driveItem/permissions/deny` | uses a non CRUD action `deny` |  | `list_file_versions` | `libre.graph/driveItem/versions/read` | `versions` is a `driveItemVersion` collection |  | `restore_file_version` | `libre.graph/driveItem/versions/update` | the only `update` action is restore |  | `list_recycle` | `libre.graph/driveItem/deleted/read` | reading a driveItem `deleted` property implies listing |  | `restore_recycle_item` | `libre.graph/driveItem/deleted/update` | the only `update` action is restore |  | `purge_recycle` | `libre.graph/driveItem/deleted/delete` | allows purging deleted `driveItems` |   Managing drives would be a different entity. A space manager role could be written as `libre.graph/drive/permission/allTasks`. 
     */
    'allowedResourceActions'?: Array<string>;
    /**
     * Optional constraints that must be met for the permission to be effective. Not supported for custom roles.  Conditions define constraints that must be met. For example, a requirement that target resource must have a certain property. The following are the supported conditions:  * Drive: `exists @Resource.Drive` - The target resource must be a drive/space * Folder: `exists @Resource.Folder` - The target resource must be a folder * File: `exists @Resource.File` - The target resource must be a file  The following is an example of a role permission with a condition that the target resource is a folder: ```json   \"rolePermissions\": [       {           \"allowedResourceActions\": [               \"libre.graph/applications/basic/update\",               \"libre.graph/applications/credentials/update\"           ],           \"condition\":  \"exists @Resource.File\"       }   ] ``` Conditions aren\'t supported for custom roles. 
     */
    'condition'?: string;
}
/**
 * Represents an Active Directory user object.
 */
export interface User {
    /**
     * Read-only.
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     */
    'accountEnabled'?: boolean;
    /**
     * The apps and app roles which this user has been assigned.
     */
    'appRoleAssignments'?: Array<AppRoleAssignment>;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     */
    'displayName': string;
    /**
     * A collection of drives available for this user. Read-only.
     */
    'drives'?: Array<Drive>;
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory.
     */
    'onPremisesSamAccountName': string;
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     */
    'givenName'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, \"Guest\" for guest users or \"Federated\" for users imported from a federated instance.
     */
    'userType'?: string;
    /**
     * Represents the users language setting, ISO-639-1 Code
     */
    'preferredLanguage'?: string;
    'signInActivity'?: SignInActivity;
    /**
     * A unique identifier assigned to the user by the organization.
     */
    'externalID'?: string;
    /**
     * A unique reference to the user. This is used to query the user from a different oCIS instance connected to the same identity provider.
     */
    'crossInstanceReference'?: string;
    /**
     * oCIS instances that the user is either a member or a guest of.
     */
    'instances'?: Array<Instance>;
}
/**
 * Represents updates to an Active Directory user object.
 */
export interface UserUpdate {
    /**
     * Read-only.
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     */
    'accountEnabled'?: boolean;
    /**
     * The apps and app roles which this user has been assigned.
     */
    'appRoleAssignments'?: Array<AppRoleAssignment>;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     */
    'drives'?: Array<Drive>;
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory.
     */
    'onPremisesSamAccountName'?: string;
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     */
    'givenName'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, \"Guest\" for guest users or \"Federated\" for users imported from a federated instance.
     */
    'userType'?: string;
    /**
     * Represents the users language setting, ISO-639-1 Code
     */
    'preferredLanguage'?: string;
    'signInActivity'?: SignInActivity;
    /**
     * A unique identifier assigned to the user by the organization.
     */
    'externalID'?: string;
    /**
     * A unique reference to the user. This is used to query the user from a different oCIS instance connected to the same identity provider.
     */
    'crossInstanceReference'?: string;
    /**
     * oCIS instances that the user is either a member or a guest of.
     */
    'instances'?: Array<Instance>;
}
/**
 * The video resource groups video-related data items into a single structure.  If a driveItem has a non-null video facet, the item represents a video file. The properties of the video resource are populated by extracting metadata from the file. 
 */
export interface Video {
    /**
     * Number of audio bits per sample.
     */
    'audioBitsPerSample'?: number;
    /**
     * Number of audio channels.
     */
    'audioChannels'?: number;
    /**
     * Name of the audio format (AAC, MP3, etc.).
     */
    'audioFormat'?: string;
    /**
     * Number of audio samples per second.
     */
    'audioSamplesPerSecond'?: number;
    /**
     * Bit rate of the video in bits per second.
     */
    'bitrate'?: number;
    /**
     * Duration of the file in milliseconds.
     */
    'duration'?: number;
    /**
     * \\\"Four character code\\\" name of the video format.
     */
    'fourCC'?: string;
    /**
     * Frame rate of the video.
     */
    'frameRate'?: number;
    /**
     * Height of the video, in pixels.
     */
    'height'?: number;
    /**
     * Width of the video, in pixels.
     */
    'width'?: number;
}

/**
 * ActivitiesApi - axios parameter creator
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (kql?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/extensions/org.libregraph/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (kql !== undefined) {
                localVarQueryParameter['kql'] = kql;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(kql?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfActivities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(kql, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.getActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(kql?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfActivities> {
            return localVarFp.getActivities(kql, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get activities
     * @param {string} [kql] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActivities(kql?: string, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getActivities(kql, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsApi - axios parameter creator
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/v1.0/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfApplications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfApplications> {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary Get application by id
     * @param {string} applicationId key: id of application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listApplications(options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DriveItemApi - axios parameter creator
 */
export const DriveItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveItem: async (driveId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteDriveItem', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveItem: async (driveId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getDriveItem', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveItem: async (driveId: string, itemId: string, driveItem: DriveItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateDriveItem', 'itemId', itemId)
            // verify required parameter 'driveItem' is not null or undefined
            assertParamExists('updateDriveItem', 'driveItem', driveItem)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriveItemApi - functional programming interface
 */
export const DriveItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriveItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDriveItem(driveId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.deleteDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDriveItem(driveId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.getDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDriveItem(driveId, itemId, driveItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.updateDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DriveItemApi - factory interface
 */
export const DriveItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriveItemApiFp(configuration)
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDriveItem(driveId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<DriveItem> {
            return localVarFp.getDriveItem(driveId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: RawAxiosRequestConfig): AxiosPromise<DriveItem> {
            return localVarFp.updateDriveItem(driveId, itemId, driveItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriveItemApi - object-oriented interface
 */
export class DriveItemApi extends BaseAPI {
    /**
     * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
     * @summary Delete a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).deleteDriveItem(driveId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a DriveItem by using its ID. 
     * @summary Get a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).getDriveItem(driveId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
     * @summary Update a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItem} driveItem DriveItem properties to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).updateDriveItem(driveId, itemId, driveItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesApi - axios parameter creator
 */
export const DrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive: async (drive: Drive, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drive' is not null or undefined
            assertParamExists('createDrive', 'drive', drive)
            const localVarPath = `/v1.0/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new drive of a specific type. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles.
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveBeta: async (drive: Drive, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drive' is not null or undefined
            assertParamExists('createDriveBeta', 'drive', drive)
            const localVarPath = `/v1beta1/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive: async (driveId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDrive', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific space. Alias for \'/v1.0/drives\'.
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveBeta: async (driveId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDriveBeta', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDrive', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get drive by id. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveBeta: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDriveBeta', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive: async (driveId: string, driveUpdate: DriveUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDrive', 'driveId', driveId)
            // verify required parameter 'driveUpdate' is not null or undefined
            assertParamExists('updateDrive', 'driveUpdate', driveUpdate)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the drive. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveBeta: async (driveId: string, driveUpdate: DriveUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDriveBeta', 'driveId', driveId)
            // verify required parameter 'driveUpdate' is not null or undefined
            assertParamExists('updateDriveBeta', 'driveUpdate', driveUpdate)
            const localVarPath = `/v1beta1/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesApi - functional programming interface
 */
export const DrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrive(drive: Drive, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrive(drive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.createDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new drive of a specific type. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles.
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDriveBeta(drive: Drive, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDriveBeta(drive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.createDriveBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDrive(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrive(driveId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.deleteDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific space. Alias for \'/v1.0/drives\'.
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDriveBeta(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDriveBeta(driveId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.deleteDriveBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrive(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDrive(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.getDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get drive by id. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDriveBeta(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDriveBeta(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.getDriveBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrive(driveId, driveUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.updateDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the drive. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDriveBeta(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDriveBeta(driveId, driveUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.updateDriveBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesApi - factory interface
 */
export const DrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive(drive: Drive, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.createDrive(drive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new drive of a specific type. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles.
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveBeta(drive: Drive, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.createDriveBeta(drive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDrive(driveId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific space. Alias for \'/v1.0/drives\'.
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveBeta(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDriveBeta(driveId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive(driveId: string, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.getDrive(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get drive by id. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveBeta(driveId: string, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.getDriveBeta(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.updateDrive(driveId, driveUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the drive. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveBeta(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.updateDriveBeta(driveId, driveUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesApi - object-oriented interface
 */
export class DrivesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new drive of a specific type
     * @param {Drive} drive New space property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDrive(drive: Drive, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).createDrive(drive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new drive of a specific type. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles.
     * @param {Drive} drive New space property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDriveBeta(drive: Drive, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).createDriveBeta(drive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific space
     * @param {string} driveId key: id of drive
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDrive(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).deleteDrive(driveId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific space. Alias for \'/v1.0/drives\'.
     * @param {string} driveId key: id of drive
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDriveBeta(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).deleteDriveBeta(driveId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get drive by id
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDrive(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).getDrive(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get drive by id. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDriveBeta(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).getDriveBeta(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the drive
     * @param {string} driveId key: id of drive
     * @param {DriveUpdate} driveUpdate New space values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).updateDrive(driveId, driveUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the drive. Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} driveId key: id of drive
     * @param {DriveUpdate} driveUpdate New space values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDriveBeta(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).updateDriveBeta(driveId, driveUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesGetDrivesApi - axios parameter creator
 */
export const DrivesGetDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrivesBeta: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesGetDrivesApi - functional programming interface
 */
export const DrivesGetDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesGetDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDrives($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesGetDrivesApi.listAllDrives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDrivesBeta($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesGetDrivesApi.listAllDrivesBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesGetDrivesApi - factory interface
 */
export const DrivesGetDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesGetDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDrives1> {
            return localVarFp.listAllDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDrives1> {
            return localVarFp.listAllDrivesBeta($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesGetDrivesApi - object-oriented interface
 */
export class DrivesGetDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all available drives
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAllDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return DrivesGetDrivesApiFp(this.configuration).listAllDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAllDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return DrivesGetDrivesApiFp(this.configuration).listAllDrivesBeta($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesPermissionsApi - axios parameter creator
 */
export const DrivesPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink: async (driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createLink', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('createLink', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/createLink`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemCreateLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (driveId: string, itemId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deletePermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deletePermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('deletePermission', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: async (driveId: string, itemId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getPermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getPermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('getPermission', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite: async (driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('invite', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('invite', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/invite`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (driveId: string, itemId: string, $filter?: string, $select?: Set<ListPermissionsSelectEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('listPermissions', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('listPermissions', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPassword: async (driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('setPermissionPassword', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('setPermissionPassword', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('setPermissionPassword', 'permId', permId)
            // verify required parameter 'sharingLinkPassword' is not null or undefined
            assertParamExists('setPermissionPassword', 'sharingLinkPassword', sharingLinkPassword)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}/setPassword`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharingLinkPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission: async (driveId: string, itemId: string, permId: string, permission: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updatePermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updatePermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('updatePermission', 'permId', permId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('updatePermission', 'permission', permission)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesPermissionsApi - functional programming interface
 */
export const DrivesPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(driveId, itemId, driveItemCreateLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.createLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(driveId, itemId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.deletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(driveId, itemId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.getPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invite(driveId, itemId, driveItemInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.invite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(driveId: string, itemId: string, $filter?: string, $select?: Set<ListPermissionsSelectEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissionsWithAllowedValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(driveId, itemId, $filter, $select, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.setPermissionPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermission(driveId, itemId, permId, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.updatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesPermissionsApi - factory interface
 */
export const DrivesPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesPermissionsApiFp(configuration)
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.createLink(driveId, itemId, driveItemCreateLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermission(driveId, itemId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.getPermission(driveId, itemId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfPermissions> {
            return localVarFp.invite(driveId, itemId, driveItemInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(driveId: string, itemId: string, $filter?: string, $select?: Set<ListPermissionsSelectEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfPermissionsWithAllowedValues> {
            return localVarFp.listPermissions(driveId, itemId, $filter, $select, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.updatePermission(driveId, itemId, permId, permission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesPermissionsApi - object-oriented interface
 */
export class DrivesPermissionsApi extends BaseAPI {
    /**
     * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
     * @summary Create a sharing link for a DriveItem
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).createLink(driveId, itemId, driveItemCreateLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
     * @summary Remove access to a DriveItem
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).deletePermission(driveId, itemId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the effective sharing permission for a particular permission resource. 
     * @summary Get sharing permission for a file or folder
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).getPermission(driveId, itemId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
     * @summary Send a sharing invitation
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).invite(driveId, itemId, driveItemInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
     * @summary List the effective sharing permissions on a driveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
     * @param {Set<ListPermissionsSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPermissions(driveId: string, itemId: string, $filter?: string, $select?: Set<ListPermissionsSelectEnum>, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).listPermissions(driveId, itemId, $filter, $select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
     * @summary Set sharing link password
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {SharingLinkPassword} sharingLinkPassword New password value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
     * @summary Update sharing permission
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {Permission} permission New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).updatePermission(driveId, itemId, permId, permission, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListPermissionsSelectEnum = {
    LibreGraphPermissionsActionsAllowedValues: '@libre.graph.permissions.actions.allowedValues',
    LibreGraphPermissionsRolesAllowedValues: '@libre.graph.permissions.roles.allowedValues',
    Value: 'value'
} as const;
export type ListPermissionsSelectEnum = typeof ListPermissionsSelectEnum[keyof typeof ListPermissionsSelectEnum];


/**
 * DrivesRootApi - axios parameter creator
 */
export const DrivesRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveItem: async (driveId: string, driveItem?: DriveItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createDriveItem', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/children`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkSpaceRoot: async (driveId: string, driveItemCreateLink?: DriveItemCreateLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createLinkSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/createLink`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemCreateLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionSpaceRoot: async (driveId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deletePermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('deletePermissionSpaceRoot', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSpaceRoot: async (driveId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getPermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('getPermissionSpaceRoot', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getRoot', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}/root`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteSpaceRoot: async (driveId: string, driveItemInvite?: DriveItemInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('inviteSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/invite`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSpaceRootSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionsSpaceRoot: async (driveId: string, $filter?: string, $select?: Set<ListPermissionsSpaceRootSelectEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('listPermissionsSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPasswordSpaceRoot: async (driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'permId', permId)
            // verify required parameter 'sharingLinkPassword' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'sharingLinkPassword', sharingLinkPassword)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}/setPassword`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharingLinkPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissionSpaceRoot: async (driveId: string, permId: string, permission: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'permId', permId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'permission', permission)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesRootApi - functional programming interface
 */
export const DrivesRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesRootApiAxiosParamCreator(configuration)
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDriveItem(driveId: string, driveItem?: DriveItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDriveItem(driveId, driveItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.createDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkSpaceRoot(driveId, driveItemCreateLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.createLinkSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionSpaceRoot(driveId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.deletePermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionSpaceRoot(driveId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.getPermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.getRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteSpaceRoot(driveId, driveItemInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.inviteSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSpaceRootSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionsSpaceRoot(driveId: string, $filter?: string, $select?: Set<ListPermissionsSpaceRootSelectEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissionsWithAllowedValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissionsSpaceRoot(driveId, $filter, $select, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.listPermissionsSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.setPermissionPasswordSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermissionSpaceRoot(driveId, permId, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.updatePermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesRootApi - factory interface
 */
export const DrivesRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesRootApiFp(configuration)
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveItem(driveId: string, driveItem?: DriveItem, options?: RawAxiosRequestConfig): AxiosPromise<DriveItem> {
            return localVarFp.createDriveItem(driveId, driveItem, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.createLinkSpaceRoot(driveId, driveItemCreateLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermissionSpaceRoot(driveId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.getPermissionSpaceRoot(driveId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(driveId: string, options?: RawAxiosRequestConfig): AxiosPromise<DriveItem> {
            return localVarFp.getRoot(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfPermissions> {
            return localVarFp.inviteSpaceRoot(driveId, driveItemInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
         * @param {Set<ListPermissionsSpaceRootSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionsSpaceRoot(driveId: string, $filter?: string, $select?: Set<ListPermissionsSpaceRootSelectEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfPermissionsWithAllowedValues> {
            return localVarFp.listPermissionsSpaceRoot(driveId, $filter, $select, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): AxiosPromise<Permission> {
            return localVarFp.updatePermissionSpaceRoot(driveId, permId, permission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesRootApi - object-oriented interface
 */
export class DrivesRootApi extends BaseAPI {
    /**
     * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
     * @summary Create a drive item
     * @param {string} driveId key: id of drive
     * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDriveItem(driveId: string, driveItem?: DriveItem, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).createDriveItem(driveId, driveItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
     * @summary Create a sharing link for the root item of a Drive
     * @param {string} driveId key: id of drive
     * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).createLinkSpaceRoot(driveId, driveItemCreateLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
     * @summary Remove access to a Drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).deletePermissionSpaceRoot(driveId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the effective sharing permission for a particular permission resource. 
     * @summary Get a single sharing permission for the root item of a drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).getPermissionSpaceRoot(driveId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get root from arbitrary space
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRoot(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).getRoot(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
     * @summary Send a sharing invitation
     * @param {string} driveId key: id of drive
     * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).inviteSpaceRoot(driveId, driveItemInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
     * @summary List the effective permissions on the root item of a drive.
     * @param {string} driveId key: id of drive
     * @param {string} [$filter] Filter items by property values. By default all permissions are returned and the avalable sharing roles are limited to normal users. To get a list of sharing roles applicable to federated users use the example $select query and combine it with $filter to omit the list of permissions.
     * @param {Set<ListPermissionsSpaceRootSelectEnum>} [$select] Select properties to be returned. By default all properties are returned. Select the roles property to fetch the available sharing roles without resolving all the permissions. Combine this with the $filter parameter to fetch the actions applicable to federated users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPermissionsSpaceRoot(driveId: string, $filter?: string, $select?: Set<ListPermissionsSpaceRootSelectEnum>, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).listPermissionsSpaceRoot(driveId, $filter, $select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
     * @summary Set sharing link password for the root item of a drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {SharingLinkPassword} sharingLinkPassword New password value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
     * @summary Update sharing permission
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {Permission} permission New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).updatePermissionSpaceRoot(driveId, permId, permission, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListPermissionsSpaceRootSelectEnum = {
    LibreGraphPermissionsActionsAllowedValues: '@libre.graph.permissions.actions.allowedValues',
    LibreGraphPermissionsRolesAllowedValues: '@libre.graph.permissions.roles.allowedValues',
    Value: 'value'
} as const;
export type ListPermissionsSpaceRootSelectEnum = typeof ListPermissionsSpaceRootSelectEnum[keyof typeof ListPermissionsSpaceRootSelectEnum];


/**
 * EducationClassApi - axios parameter creator
 */
export const EducationClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass: async (classId: string, classMemberReference: ClassMemberReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addUserToClass', 'classId', classId)
            // verify required parameter 'classMemberReference' is not null or undefined
            assertParamExists('addUserToClass', 'classMemberReference', classMemberReference)
            const localVarPath = `/v1.0/education/classes/{class-id}/members/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classMemberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass: async (educationClass: EducationClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('createClass', 'educationClass', educationClass)
            const localVarPath = `/v1.0/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClass', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass: async (classId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'userId', userId)
            const localVarPath = `/v1.0/education/classes/{class-id}/members/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getClass', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('listClassMembers', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}/members`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass: async (classId: string, educationClass: EducationClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('updateClass', 'classId', classId)
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('updateClass', 'educationClass', educationClass)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassApi - functional programming interface
 */
export const EducationClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToClass(classId, classMemberReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.addUserToClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClass(educationClass: EducationClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClass(educationClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.createClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClass(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClass(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.deleteClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromClass(classId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.deleteUserFromClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClass(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClass(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.getClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClassMembers(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClassMembers(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.listClassMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.listClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClass(classId: string, educationClass: EducationClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClass(classId, educationClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.updateClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationClassApi - factory interface
 */
export const EducationClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addUserToClass(classId, classMemberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass(educationClass: EducationClass, options?: RawAxiosRequestConfig): AxiosPromise<EducationClass> {
            return localVarFp.createClass(educationClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass(classId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass(classId: string, options?: RawAxiosRequestConfig): AxiosPromise<EducationClass> {
            return localVarFp.getClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers(classId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listClassMembers(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfClass> {
            return localVarFp.listClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass(classId: string, educationClass: EducationClass, options?: RawAxiosRequestConfig): AxiosPromise<EducationClass> {
            return localVarFp.updateClass(classId, educationClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassApi - object-oriented interface
 */
export class EducationClassApi extends BaseAPI {
    /**
     * 
     * @summary Assign a user to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassMemberReference} classMemberReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).addUserToClass(classId, classMemberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new education class
     * @param {EducationClass} educationClass New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createClass(educationClass: EducationClass, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).createClass(educationClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete education class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteClass(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign from class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteUserFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get class by key
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClass(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).getClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listClassMembers(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClassMembers(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list education classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listClasses(options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a education class
     * @param {string} classId key: id or externalId of class
     * @param {EducationClass} educationClass New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateClass(classId: string, educationClass: EducationClass, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).updateClass(classId, educationClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationClassTeachersApi - axios parameter creator
 */
export const EducationClassTeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass: async (classId: string, classTeacherReference: ClassTeacherReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addTeacherToClass', 'classId', classId)
            // verify required parameter 'classTeacherReference' is not null or undefined
            assertParamExists('addTeacherToClass', 'classTeacherReference', classTeacherReference)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classTeacherReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass: async (classId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'userId', userId)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getTeachers', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassTeachersApi - functional programming interface
 */
export const EducationClassTeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassTeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeacherToClass(classId, classTeacherReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.addTeacherToClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeacherFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeacherFromClass(classId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.deleteTeacherFromClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.getTeachers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationClassTeachersApi - factory interface
 */
export const EducationClassTeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassTeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addTeacherToClass(classId, classTeacherReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTeacherFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(classId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.getTeachers(classId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassTeachersApi - object-oriented interface
 */
export class EducationClassTeachersApi extends BaseAPI {
    /**
     * 
     * @summary Assign a teacher to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).addTeacherToClass(classId, classTeacherReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user as teacher of a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTeacherFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).deleteTeacherFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the teachers for a class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTeachers(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).getTeachers(classId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationSchoolApi - axios parameter creator
 */
export const EducationSchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool: async (schoolId: string, classReference: ClassReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addClassToSchool', 'schoolId', schoolId)
            // verify required parameter 'classReference' is not null or undefined
            assertParamExists('addClassToSchool', 'classReference', classReference)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool: async (schoolId: string, educationUserReference: EducationUserReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addUserToSchool', 'schoolId', schoolId)
            // verify required parameter 'educationUserReference' is not null or undefined
            assertParamExists('addUserToSchool', 'educationUserReference', educationUserReference)
            const localVarPath = `/v1.0/education/schools/{school-id}/users/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUserReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool: async (educationSchool: EducationSchool, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('createSchool', 'educationSchool', educationSchool)
            const localVarPath = `/v1.0/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool: async (schoolId: string, classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'schoolId', schoolId)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'classId', classId)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes/{class-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteSchool', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool: async (schoolId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'schoolId', schoolId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'userId', userId)
            const localVarPath = `/v1.0/education/schools/{school-id}/users/{user-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('getSchool', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolClasses', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolUsers', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}/users`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool: async (schoolId: string, educationSchool: EducationSchool, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('updateSchool', 'schoolId', schoolId)
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('updateSchool', 'educationSchool', educationSchool)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationSchoolApi - functional programming interface
 */
export const EducationSchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationSchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClassToSchool(schoolId: string, classReference: ClassReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClassToSchool(schoolId, classReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.addClassToSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToSchool(schoolId, educationUserReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.addUserToSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchool(educationSchool: EducationSchool, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchool(educationSchool, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.createSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClassFromSchool(schoolId: string, classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClassFromSchool(schoolId, classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteClassFromSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchool(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchool(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromSchool(schoolId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromSchool(schoolId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteUserFromSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchool(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.getSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolClasses(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolClasses(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchoolClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolUsers(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolUsers(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchoolUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchools(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchools(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchool(schoolId: string, educationSchool: EducationSchool, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchool(schoolId, educationSchool, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.updateSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationSchoolApi - factory interface
 */
export const EducationSchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationSchoolApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool(schoolId: string, classReference: ClassReference, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addClassToSchool(schoolId, classReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addUserToSchool(schoolId, educationUserReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool(educationSchool: EducationSchool, options?: RawAxiosRequestConfig): AxiosPromise<EducationSchool> {
            return localVarFp.createSchool(educationSchool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool(schoolId: string, classId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteClassFromSchool(schoolId, classId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool(schoolId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool(schoolId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserFromSchool(schoolId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(schoolId: string, options?: RawAxiosRequestConfig): AxiosPromise<EducationSchool> {
            return localVarFp.getSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses(schoolId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfEducationClass> {
            return localVarFp.listSchoolClasses(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers(schoolId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listSchoolUsers(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfSchools> {
            return localVarFp.listSchools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool(schoolId: string, educationSchool: EducationSchool, options?: RawAxiosRequestConfig): AxiosPromise<EducationSchool> {
            return localVarFp.updateSchool(schoolId, educationSchool, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationSchoolApi - object-oriented interface
 */
export class EducationSchoolApi extends BaseAPI {
    /**
     * 
     * @summary Assign a class to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {ClassReference} classReference educationClass to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addClassToSchool(schoolId: string, classReference: ClassReference, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addClassToSchool(schoolId, classReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a user to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationUserReference} educationUserReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addUserToSchool(schoolId, educationUserReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new school
     * @param {EducationSchool} educationSchool New school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSchool(educationSchool: EducationSchool, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).createSchool(educationSchool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign class from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} classId key: id or externalId of the class to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteClassFromSchool(schoolId: string, classId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteClassFromSchool(schoolId, classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
     * @summary Delete school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSchool(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} userId key: id or username of the user to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserFromSchool(schoolId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteUserFromSchool(schoolId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the properties of a specific school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSchool(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).getSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSchoolClasses(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolClasses(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationUser resources associated with an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSchoolUsers(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolUsers(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of schools and their properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSchools(options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationSchool} educationSchool New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSchool(schoolId: string, educationSchool: EducationSchool, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).updateSchool(schoolId, educationSchool, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationUserApi - axios parameter creator
 */
export const EducationUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser: async (educationUser: EducationUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('createEducationUser', 'educationUser', educationUser)
            const localVarPath = `/v1.0/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteEducationUser', 'userId', userId)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser: async (userId: string, $expand?: Set<GetEducationUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getEducationUser', 'userId', userId)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers: async ($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser: async (userId: string, educationUser: EducationUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEducationUser', 'userId', userId)
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('updateEducationUser', 'educationUser', educationUser)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationUserApi - functional programming interface
 */
export const EducationUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEducationUser(educationUser: EducationUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEducationUser(educationUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.createEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEducationUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEducationUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.deleteEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEducationUser(userId, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.getEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEducationUsers($orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.listEducationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEducationUser(userId: string, educationUser: EducationUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEducationUser(userId, educationUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.updateEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationUserApi - factory interface
 */
export const EducationUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser(educationUser: EducationUser, options?: RawAxiosRequestConfig): AxiosPromise<EducationUser> {
            return localVarFp.createEducationUser(educationUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEducationUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<EducationUser> {
            return localVarFp.getEducationUser(userId, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listEducationUsers($orderby, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser(userId: string, educationUser: EducationUser, options?: RawAxiosRequestConfig): AxiosPromise<EducationUser> {
            return localVarFp.updateEducationUser(userId, educationUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationUserApi - object-oriented interface
 */
export class EducationUserApi extends BaseAPI {
    /**
     * 
     * @summary Add new education user
     * @param {EducationUser} educationUser New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEducationUser(educationUser: EducationUser, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).createEducationUser(educationUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete educationUser
     * @param {string} userId key: id or username of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEducationUser(userId: string, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).deleteEducationUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).getEducationUser(userId, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from education users
     * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).listEducationUsers($orderby, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {EducationUser} educationUser New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEducationUser(userId: string, educationUser: EducationUser, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).updateEducationUser(userId, educationUser, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetEducationUserExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type GetEducationUserExpandEnum = typeof GetEducationUserExpandEnum[keyof typeof GetEducationUserExpandEnum];
export const ListEducationUsersOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc',
    Mail: 'mail',
    MailDesc: 'mail desc',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    OnPremisesSamAccountNameDesc: 'onPremisesSamAccountName desc'
} as const;
export type ListEducationUsersOrderbyEnum = typeof ListEducationUsersOrderbyEnum[keyof typeof ListEducationUsersOrderbyEnum];
export const ListEducationUsersExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type ListEducationUsersExpandEnum = typeof ListEducationUsersExpandEnum[keyof typeof ListEducationUsersExpandEnum];


/**
 * GroupApi - axios parameter creator
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember: async (groupId: string, memberReference: MemberReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addMember', 'groupId', groupId)
            // verify required parameter 'memberReference' is not null or undefined
            assertParamExists('addMember', 'memberReference', memberReference)
            const localVarPath = `/v1.0/groups/{group-id}/members/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (groupId: string, directoryObjectId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteMember', 'groupId', groupId)
            // verify required parameter 'directoryObjectId' is not null or undefined
            assertParamExists('deleteMember', 'directoryObjectId', directoryObjectId)
            const localVarPath = `/v1.0/groups/{group-id}/members/{directory-object-id}/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"directory-object-id"}}`, encodeURIComponent(String(directoryObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listMembers', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}/members`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (groupId: string, group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroup', 'groupId', groupId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroup', 'group', group)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMember(groupId: string, memberReference: MemberReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMember(groupId, memberReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.addMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(groupId, directoryObjectId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(groupId: string, group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(groupId, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.updateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember(groupId: string, memberReference: MemberReference, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addMember(groupId, memberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfUsers> {
            return localVarFp.listMembers(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, group: Group, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGroup(groupId, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Add a member to a group
     * @param {string} groupId key: id of group
     * @param {MemberReference} memberReference Object to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addMember(groupId: string, memberReference: MemberReference, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).addMember(groupId, memberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from groups
     * @param {string} groupId key: id of group
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroup(groupId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete member from a group
     * @param {string} groupId key: id of group
     * @param {string} directoryObjectId key: id of group member to remove
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from groups by key
     * @param {string} groupId key: id or name of group
     * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
     * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(groupId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of the group\'s direct members
     * @param {string} groupId key: id or name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMembers(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).listMembers(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in groups
     * @param {string} groupId key: id of group
     * @param {Group} group New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGroup(groupId: string, group: Group, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(groupId, group, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetGroupSelectEnum = {
    Id: 'id',
    Description: 'description',
    DisplayName: 'displayName',
    Members: 'members'
} as const;
export type GetGroupSelectEnum = typeof GetGroupSelectEnum[keyof typeof GetGroupSelectEnum];
export const GetGroupExpandEnum = {
    Members: 'members'
} as const;
export type GetGroupExpandEnum = typeof GetGroupExpandEnum[keyof typeof GetGroupExpandEnum];


/**
 * GroupsApi - axios parameter creator
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/v1.0/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async ($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups($search, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.createGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfGroup> {
            return localVarFp.listGroups($search, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to groups
     * @param {Group} group New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGroup(group: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from groups
     * @param {string} [$search] Search items by search phrases
     * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
     * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups($search, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListGroupsOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc'
} as const;
export type ListGroupsOrderbyEnum = typeof ListGroupsOrderbyEnum[keyof typeof ListGroupsOrderbyEnum];
export const ListGroupsSelectEnum = {
    Id: 'id',
    Description: 'description',
    DisplayName: 'displayName',
    Mail: 'mail',
    Members: 'members'
} as const;
export type ListGroupsSelectEnum = typeof ListGroupsSelectEnum[keyof typeof ListGroupsSelectEnum];
export const ListGroupsExpandEnum = {
    Members: 'members'
} as const;
export type ListGroupsExpandEnum = typeof ListGroupsExpandEnum[keyof typeof ListGroupsExpandEnum];


/**
 * MeChangepasswordApi - axios parameter creator
 */
export const MeChangepasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword: async (passwordChange: PasswordChange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChange' is not null or undefined
            assertParamExists('changeOwnPassword', 'passwordChange', passwordChange)
            const localVarPath = `/v1.0/me/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeChangepasswordApi - functional programming interface
 */
export const MeChangepasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeChangepasswordApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOwnPassword(passwordChange: PasswordChange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOwnPassword(passwordChange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeChangepasswordApi.changeOwnPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeChangepasswordApi - factory interface
 */
export const MeChangepasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeChangepasswordApiFp(configuration)
    return {
        /**
         * 
         * @summary Change your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword(passwordChange: PasswordChange, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeOwnPassword(passwordChange, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeChangepasswordApi - object-oriented interface
 */
export class MeChangepasswordApi extends BaseAPI {
    /**
     * 
     * @summary Change your own password
     * @param {PasswordChange} passwordChange Password change request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changeOwnPassword(passwordChange: PasswordChange, options?: RawAxiosRequestConfig) {
        return MeChangepasswordApiFp(this.configuration).changeOwnPassword(passwordChange, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveApi - axios parameter creator
 */
export const MeDriveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedByMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drive/sharedByMe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedWithMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drive/sharedWithMe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveApi - functional programming interface
 */
export const MeDriveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHome(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHome(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.getHome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharedByMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharedByMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.listSharedByMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharedWithMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharedWithMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.listSharedWithMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveApi - factory interface
 */
export const MeDriveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveApiFp(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome(options?: RawAxiosRequestConfig): AxiosPromise<Drive> {
            return localVarFp.getHome(options).then((request) => request(axios, basePath));
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedByMe(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDriveItems1> {
            return localVarFp.listSharedByMe(options).then((request) => request(axios, basePath));
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedWithMe(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDriveItems1> {
            return localVarFp.listSharedWithMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveApi - object-oriented interface
 */
export class MeDriveApi extends BaseAPI {
    /**
     * 
     * @summary Get personal space for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHome(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).getHome(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
     * @summary Get a list of driveItem objects shared by the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSharedByMe(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).listSharedByMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
     * @summary Get a list of driveItem objects shared with the owner of a drive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSharedWithMe(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).listSharedWithMe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveRootApi - axios parameter creator
 */
export const MeDriveRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootApi - functional programming interface
 */
export const MeDriveRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetRoot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetRoot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveRootApi.homeGetRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveRootApi - factory interface
 */
export const MeDriveRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootApiFp(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot(options?: RawAxiosRequestConfig): AxiosPromise<DriveItem> {
            return localVarFp.homeGetRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootApi - object-oriented interface
 */
export class MeDriveRootApi extends BaseAPI {
    /**
     * 
     * @summary Get root from personal space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public homeGetRoot(options?: RawAxiosRequestConfig) {
        return MeDriveRootApiFp(this.configuration).homeGetRoot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveRootChildrenApi - axios parameter creator
 */
export const MeDriveRootChildrenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive/root/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootChildrenApi - functional programming interface
 */
export const MeDriveRootChildrenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootChildrenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetChildren(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetChildren(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveRootChildrenApi.homeGetChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveRootChildrenApi - factory interface
 */
export const MeDriveRootChildrenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootChildrenApiFp(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDriveItems> {
            return localVarFp.homeGetChildren(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootChildrenApi - object-oriented interface
 */
export class MeDriveRootChildrenApi extends BaseAPI {
    /**
     * 
     * @summary Get children from drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public homeGetChildren(options?: RawAxiosRequestConfig) {
        return MeDriveRootChildrenApiFp(this.configuration).homeGetChildren(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDrivesApi - axios parameter creator
 */
export const MeDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrivesBeta: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDrivesApi - functional programming interface
 */
export const MeDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyDrives($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDrivesApi.listMyDrives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyDrivesBeta($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDrivesApi.listMyDrivesBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDrivesApi - factory interface
 */
export const MeDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDrives> {
            return localVarFp.listMyDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDrives> {
            return localVarFp.listMyDrivesBeta($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDrivesApi - object-oriented interface
 */
export class MeDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all drives where the current user is a regular member of
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return MeDrivesApiFp(this.configuration).listMyDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return MeDrivesApiFp(this.configuration).listMyDrivesBeta($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeUserApi - axios parameter creator
 */
export const MeUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser: async ($expand?: Set<GetOwnUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the current user
         * @param {UserUpdate} [userUpdate] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnUser: async (userUpdate?: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeUserApi - functional programming interface
 */
export const MeUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnUser($expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeUserApi.getOwnUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the current user
         * @param {UserUpdate} [userUpdate] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOwnUser(userUpdate?: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOwnUser(userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeUserApi.updateOwnUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeUserApi - factory interface
 */
export const MeUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getOwnUser($expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the current user
         * @param {UserUpdate} [userUpdate] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnUser(userUpdate?: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateOwnUser(userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeUserApi - object-oriented interface
 */
export class MeUserApi extends BaseAPI {
    /**
     * 
     * @summary Get current user
     * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return MeUserApiFp(this.configuration).getOwnUser($expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the current user
     * @param {UserUpdate} [userUpdate] New user values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOwnUser(userUpdate?: UserUpdate, options?: RawAxiosRequestConfig) {
        return MeUserApiFp(this.configuration).updateOwnUser(userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetOwnUserExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type GetOwnUserExpandEnum = typeof GetOwnUserExpandEnum[keyof typeof GetOwnUserExpandEnum];


/**
 * RoleManagementApi - axios parameter creator
 */
export const RoleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionRoleDefinition: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getPermissionRoleDefinition', 'roleId', roleId)
            const localVarPath = `/v1beta1/roleManagement/permissions/roleDefinitions/{role-id}`
                .replace(`{${"role-id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionRoleDefinitions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/roleManagement/permissions/roleDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleManagementApi - functional programming interface
 */
export const RoleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionRoleDefinition(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedRoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionRoleDefinition(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.getPermissionRoleDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionRoleDefinitions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedRoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissionRoleDefinitions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.listPermissionRoleDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleManagementApi - factory interface
 */
export const RoleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleManagementApiFp(configuration)
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionRoleDefinition(roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<UnifiedRoleDefinition> {
            return localVarFp.getPermissionRoleDefinition(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionRoleDefinitions(options?: RawAxiosRequestConfig): AxiosPromise<UnifiedRoleDefinition> {
            return localVarFp.listPermissionRoleDefinitions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleManagementApi - object-oriented interface
 */
export class RoleManagementApi extends BaseAPI {
    /**
     * Read the properties and relationships of a `unifiedRoleDefinition` object. 
     * @summary Get unifiedRoleDefinition
     * @param {string} roleId key: id of roleDefinition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPermissionRoleDefinition(roleId: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).getPermissionRoleDefinition(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
     * @summary List roleDefinitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPermissionRoleDefinitions(options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).listPermissionRoleDefinitions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags: async (tagAssignment?: TagAssignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags: async (tagUnassignment?: TagUnassignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUnassignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTags(tagAssignment?: TagAssignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTags(tagAssignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.assignTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignTags(tagUnassignment?: TagUnassignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTags(tagUnassignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.unassignTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags(tagAssignment?: TagAssignment, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assignTags(tagAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTags> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags(tagUnassignment?: TagUnassignment, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unassignTags(tagUnassignment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Assign tags to a resource
     * @param {TagAssignment} [tagAssignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public assignTags(tagAssignment?: TagAssignment, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).assignTags(tagAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all known tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTags(options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign tags from a resource
     * @param {TagUnassignment} [tagUnassignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unassignTags(tagUnassignment?: TagUnassignment, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).unassignTags(tagUnassignment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData: async (userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('exportPersonalData', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}/exportPersonalData`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportPersonalDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {UserUpdate} userUpdate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUser', 'userUpdate', userUpdate)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPersonalData(userId, exportPersonalDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.exportPersonalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {UserUpdate} userUpdate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(userId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {UserUpdate} userUpdate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(userId, userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from users
     * @param {string} userId key: id or name of user
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary export personal data of a user
     * @param {string} userId key: id or name of user
     * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from users by key
     * @param {string} userId key: id or name of user
     * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
     * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in users
     * @param {string} userId key: id of user
     * @param {UserUpdate} userUpdate New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUser(userId: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetUserSelectEnum = {
    Id: 'id',
    DisplayName: 'displayName',
    Drive: 'drive',
    Drives: 'drives',
    Mail: 'mail',
    MemberOf: 'memberOf',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    Surname: 'surname'
} as const;
export type GetUserSelectEnum = typeof GetUserSelectEnum[keyof typeof GetUserSelectEnum];
export const GetUserExpandEnum = {
    Drive: 'drive',
    Drives: 'drives',
    MemberOf: 'memberOf',
    AppRoleAssignments: 'appRoleAssignments'
} as const;
export type GetUserExpandEnum = typeof GetUserExpandEnum[keyof typeof GetUserExpandEnum];


/**
 * UserAppRoleAssignmentApi - axios parameter creator
 */
export const UserAppRoleAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments: async (userId: string, appRoleAssignment: AppRoleAssignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignment' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'appRoleAssignment', appRoleAssignment)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appRoleAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments: async (userId: string, appRoleAssignmentId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignmentId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'appRoleAssignmentId', appRoleAssignmentId)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments/{appRoleAssignment-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"appRoleAssignment-id"}}`, encodeURIComponent(String(appRoleAssignmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userListAppRoleAssignments', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAppRoleAssignmentApi - functional programming interface
 */
export const UserAppRoleAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAppRoleAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppRoleAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateAppRoleAssignments(userId, appRoleAssignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userCreateAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userDeleteAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListAppRoleAssignments(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAppRoleAssignments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListAppRoleAssignments(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userListAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAppRoleAssignmentApi - factory interface
 */
export const UserAppRoleAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAppRoleAssignmentApiFp(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: RawAxiosRequestConfig): AxiosPromise<AppRoleAssignment> {
            return localVarFp.userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAppRoleAssignments> {
            return localVarFp.userListAppRoleAssignments(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAppRoleAssignmentApi - object-oriented interface
 */
export class UserAppRoleAssignmentApi extends BaseAPI {
    /**
     * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
     * @summary Grant an appRoleAssignment to a user
     * @param {string} userId key: id of user
     * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the appRoleAssignment from a user
     * @param {string} userId key: id of user
     * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Represents the global roles a user has been granted for an application.
     * @summary Get appRoleAssignments from a user
     * @param {string} userId key: id of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userListAppRoleAssignments(userId: string, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userListAppRoleAssignments(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/v1.0/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async ($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers($search, $filter, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfUser> {
            return localVarFp.listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to users
     * @param {User} user New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from users
     * @param {string} [$search] Search items by search phrases
     * @param {string} [$filter] Filter users by property values and relationship attributes
     * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
     * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListUsersOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc',
    Mail: 'mail',
    MailDesc: 'mail desc',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    OnPremisesSamAccountNameDesc: 'onPremisesSamAccountName desc'
} as const;
export type ListUsersOrderbyEnum = typeof ListUsersOrderbyEnum[keyof typeof ListUsersOrderbyEnum];
export const ListUsersSelectEnum = {
    Id: 'id',
    DisplayName: 'displayName',
    Mail: 'mail',
    MemberOf: 'memberOf',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    Surname: 'surname'
} as const;
export type ListUsersSelectEnum = typeof ListUsersSelectEnum[keyof typeof ListUsersSelectEnum];
export const ListUsersExpandEnum = {
    Drive: 'drive',
    Drives: 'drives',
    MemberOf: 'memberOf',
    AppRoleAssignments: 'appRoleAssignments'
} as const;
export type ListUsersExpandEnum = typeof ListUsersExpandEnum[keyof typeof ListUsersExpandEnum];


