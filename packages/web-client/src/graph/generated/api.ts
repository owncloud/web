/* tslint:disable */
/* eslint-disable */
/**
 * Libre Graph API
 * Libre Graph is a free API for cloud collaboration inspired by the MS Graph API.
 *
 * The version of the OpenAPI document: v1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents activity.
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * Activity ID.
     * @type {string}
     * @memberof Activity
     */
    'id': string;
    /**
     * 
     * @type {ActivityTimes}
     * @memberof Activity
     */
    'times': ActivityTimes;
    /**
     * 
     * @type {ActivityTemplate}
     * @memberof Activity
     */
    'template': ActivityTemplate;
}
/**
 * 
 * @export
 * @interface ActivityTemplate
 */
export interface ActivityTemplate {
    /**
     * Activity description.
     * @type {string}
     * @memberof ActivityTemplate
     */
    'message': string;
    /**
     * Activity description variables.
     * @type {object}
     * @memberof ActivityTemplate
     */
    'variables'?: object;
}
/**
 * 
 * @export
 * @interface ActivityTimes
 */
export interface ActivityTimes {
    /**
     * Timestamp of the activity.
     * @type {string}
     * @memberof ActivityTimes
     */
    'recordedTime': string;
}
/**
 * 
 * @export
 * @interface AppRole
 */
export interface AppRole {
    /**
     * Specifies whether this app role can be assigned to users and groups (by setting to [\'User\']), to other application\'s (by setting to [\'Application\'], or both (by setting to [\'User\', \'Application\']). App roles supporting assignment to other applications\' service principals are also known as application permissions. The \'Application\' value is only supported for app roles defined on application entities.
     * @type {Array<string>}
     * @memberof AppRole
     */
    'allowedMemberTypes'?: Array<string>;
    /**
     * The description for the app role. This is displayed when the app role is being assigned and, if the app role functions as an application permission, during  consent experiences.
     * @type {string}
     * @memberof AppRole
     */
    'description'?: string | null;
    /**
     * Display name for the permission that appears in the app role assignment and consent experiences.
     * @type {string}
     * @memberof AppRole
     */
    'displayName'?: string | null;
    /**
     * Unique role identifier inside the appRoles collection. When creating a new app role, a new GUID identifier must be provided.
     * @type {string}
     * @memberof AppRole
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AppRoleAssignment
 */
export interface AppRoleAssignment {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'deletedDateTime'?: string;
    /**
     * The identifier (id) for the app role which is assigned to the user. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'appRoleId': string;
    /**
     * The time when the app role assignment was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'createdDateTime'?: string | null;
    /**
     * The display name of the user, group, or service principal that was granted the app role assignment. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the user, security group, or service principal being granted the app role. Security groups with dynamic memberships are supported. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalId': string | null;
    /**
     * The type of the assigned principal. This can either be User, Group, or ServicePrincipal. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalType'?: string | null;
    /**
     * The display name of the resource app\'s service principal to which the assignment is made.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'resourceDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the resource service principal for which the assignment is made. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'resourceId': string | null;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * The collection of roles defined for the application. With app role assignments, these roles can be assigned to users, groups, or service principals associated with other applications. Not nullable.
     * @type {Array<AppRole>}
     * @memberof Application
     */
    'appRoles'?: Array<AppRole>;
    /**
     * The display name for the application.
     * @type {string}
     * @memberof Application
     */
    'displayName'?: string | null;
}
/**
 * The Audio resource groups audio-related properties on an item into a single structure.  If a DriveItem has a non-null audio facet, the item represents an audio file. The properties of the Audio resource are populated by extracting metadata from the file. 
 * @export
 * @interface Audio
 */
export interface Audio {
    /**
     * The title of the album for this audio file.
     * @type {string}
     * @memberof Audio
     */
    'album'?: string;
    /**
     * The artist named on the album for the audio file.
     * @type {string}
     * @memberof Audio
     */
    'albumArtist'?: string;
    /**
     * The performing artist for the audio file.
     * @type {string}
     * @memberof Audio
     */
    'artist'?: string;
    /**
     * Bitrate expressed in kbps.
     * @type {number}
     * @memberof Audio
     */
    'bitrate'?: number;
    /**
     * The name of the composer of the audio file.
     * @type {string}
     * @memberof Audio
     */
    'composers'?: string;
    /**
     * Copyright information for the audio file.
     * @type {string}
     * @memberof Audio
     */
    'copyright'?: string;
    /**
     * The number of the disc this audio file came from.
     * @type {number}
     * @memberof Audio
     */
    'disc'?: number;
    /**
     * The total number of discs in this album.
     * @type {number}
     * @memberof Audio
     */
    'discCount'?: number;
    /**
     * Duration of the audio file, expressed in milliseconds
     * @type {number}
     * @memberof Audio
     */
    'duration'?: number;
    /**
     * The genre of this audio file.
     * @type {string}
     * @memberof Audio
     */
    'genre'?: string;
    /**
     * Indicates if the file is protected with digital rights management.
     * @type {boolean}
     * @memberof Audio
     */
    'hasDrm'?: boolean;
    /**
     * Indicates if the file is encoded with a variable bitrate.
     * @type {boolean}
     * @memberof Audio
     */
    'isVariableBitrate'?: boolean;
    /**
     * The title of the audio file.
     * @type {string}
     * @memberof Audio
     */
    'title'?: string;
    /**
     * The number of the track on the original disc for this audio file.
     * @type {number}
     * @memberof Audio
     */
    'track'?: number;
    /**
     * The total number of tracks on the original disc for this audio file.
     * @type {number}
     * @memberof Audio
     */
    'trackCount'?: number;
    /**
     * The year the audio file was recorded.
     * @type {number}
     * @memberof Audio
     */
    'year'?: number;
}
/**
 * 
 * @export
 * @interface ClassMemberReference
 */
export interface ClassMemberReference {
    /**
     * 
     * @type {string}
     * @memberof ClassMemberReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface ClassReference
 */
export interface ClassReference {
    /**
     * 
     * @type {string}
     * @memberof ClassReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface ClassTeacherReference
 */
export interface ClassTeacherReference {
    /**
     * 
     * @type {string}
     * @memberof ClassTeacherReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfActivities
 */
export interface CollectionOfActivities {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof CollectionOfActivities
     */
    'value'?: Array<Activity>;
}
/**
 * 
 * @export
 * @interface CollectionOfAppRoleAssignments
 */
export interface CollectionOfAppRoleAssignments {
    /**
     * 
     * @type {Array<AppRoleAssignment>}
     * @memberof CollectionOfAppRoleAssignments
     */
    'value'?: Array<AppRoleAssignment>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfAppRoleAssignments
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfApplications
 */
export interface CollectionOfApplications {
    /**
     * 
     * @type {Array<Application>}
     * @memberof CollectionOfApplications
     */
    'value'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface CollectionOfClass
 */
export interface CollectionOfClass {
    /**
     * 
     * @type {Array<EducationClass>}
     * @memberof CollectionOfClass
     */
    'value'?: Array<EducationClass>;
}
/**
 * 
 * @export
 * @interface CollectionOfDriveItems
 */
export interface CollectionOfDriveItems {
    /**
     * 
     * @type {Array<DriveItem>}
     * @memberof CollectionOfDriveItems
     */
    'value'?: Array<DriveItem>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfDriveItems
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfDriveItems1
 */
export interface CollectionOfDriveItems1 {
    /**
     * 
     * @type {Array<DriveItem>}
     * @memberof CollectionOfDriveItems1
     */
    'value'?: Array<DriveItem>;
}
/**
 * 
 * @export
 * @interface CollectionOfDrives
 */
export interface CollectionOfDrives {
    /**
     * 
     * @type {Array<Drive>}
     * @memberof CollectionOfDrives
     */
    'value'?: Array<Drive>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfDrives
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfDrives1
 */
export interface CollectionOfDrives1 {
    /**
     * 
     * @type {Array<Drive>}
     * @memberof CollectionOfDrives1
     */
    'value'?: Array<Drive>;
}
/**
 * 
 * @export
 * @interface CollectionOfEducationClass
 */
export interface CollectionOfEducationClass {
    /**
     * 
     * @type {Array<EducationClass>}
     * @memberof CollectionOfEducationClass
     */
    'value'?: Array<EducationClass>;
}
/**
 * 
 * @export
 * @interface CollectionOfEducationUser
 */
export interface CollectionOfEducationUser {
    /**
     * 
     * @type {Array<EducationUser>}
     * @memberof CollectionOfEducationUser
     */
    'value'?: Array<EducationUser>;
}
/**
 * 
 * @export
 * @interface CollectionOfGroup
 */
export interface CollectionOfGroup {
    /**
     * 
     * @type {Array<Group>}
     * @memberof CollectionOfGroup
     */
    'value'?: Array<Group>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfGroup
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfPermissions
 */
export interface CollectionOfPermissions {
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CollectionOfPermissions
     */
    'value'?: Array<Permission>;
}
/**
 * 
 * @export
 * @interface CollectionOfPermissionsWithAllowedValues
 */
export interface CollectionOfPermissionsWithAllowedValues {
    /**
     * A list of role definitions that can be chosen for the resource.
     * @type {Array<UnifiedRoleDefinition>}
     * @memberof CollectionOfPermissionsWithAllowedValues
     */
    '@libre.graph.permissions.roles.allowedValues'?: Array<UnifiedRoleDefinition>;
    /**
     * A list of actions that can be chosen for a custom role.  Following the CS3 API we can represent the CS3 permissions by mapping them to driveItem properties or relations like this: | [CS3 ResourcePermission](https://cs3org.github.io/cs3apis/#cs3.storage.provider.v1beta1.ResourcePermissions) | action | comment | | ------------------------------------------------------------------------------------------------------------ | ------ | ------- | | `stat` | `libre.graph/driveItem/basic/read` | `basic` because it does not include versions or trashed items | | `get_quota` | `libre.graph/driveItem/quota/read` | read only the `quota` property | | `get_path` | `libre.graph/driveItem/path/read` | read only the `path` property | | `move` | `libre.graph/driveItem/path/update` | allows updating the `path` property of a CS3 resource | | `delete` | `libre.graph/driveItem/standard/delete` | `standard` because deleting is a common update operation | | `list_container` | `libre.graph/driveItem/children/read` | | | `create_container` | `libre.graph/driveItem/children/create` | | | `initiate_file_download` | `libre.graph/driveItem/content/read` | `content` is the property read when initiating a download | | `initiate_file_upload` | `libre.graph/driveItem/upload/create` | `uploads` are a separate property. postprocessing creates the `content` | | `add_grant` | `libre.graph/driveItem/permissions/create` | | | `list_grant` | `libre.graph/driveItem/permissions/read` | | | `update_grant` | `libre.graph/driveItem/permissions/update` | | | `remove_grant` | `libre.graph/driveItem/permissions/delete` | | | `deny_grant` | `libre.graph/driveItem/permissions/deny` | uses a non CRUD action `deny` | | `list_file_versions` | `libre.graph/driveItem/versions/read` | `versions` is a `driveItemVersion` collection | | `restore_file_version` | `libre.graph/driveItem/versions/update` | the only `update` action is restore | | `list_recycle` | `libre.graph/driveItem/deleted/read` | reading a driveItem `deleted` property implies listing | | `restore_recycle_item` | `libre.graph/driveItem/deleted/update` | the only `update` action is restore | | `purge_recycle` | `libre.graph/driveItem/deleted/delete` | allows purging deleted `driveItems` | 
     * @type {Array<string>}
     * @memberof CollectionOfPermissionsWithAllowedValues
     */
    '@libre.graph.permissions.actions.allowedValues'?: Array<string>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CollectionOfPermissionsWithAllowedValues
     */
    'value'?: Array<Permission>;
}
/**
 * 
 * @export
 * @interface CollectionOfSchools
 */
export interface CollectionOfSchools {
    /**
     * 
     * @type {Array<EducationSchool>}
     * @memberof CollectionOfSchools
     */
    'value'?: Array<EducationSchool>;
}
/**
 * 
 * @export
 * @interface CollectionOfTags
 */
export interface CollectionOfTags {
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectionOfTags
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CollectionOfUser
 */
export interface CollectionOfUser {
    /**
     * 
     * @type {Array<User>}
     * @memberof CollectionOfUser
     */
    'value'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfUser
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfUsers
 */
export interface CollectionOfUsers {
    /**
     * 
     * @type {Array<User>}
     * @memberof CollectionOfUsers
     */
    'value'?: Array<User>;
}
/**
 * Information about the deleted state of the item. Read-only.
 * @export
 * @interface Deleted
 */
export interface Deleted {
    /**
     * Represents the state of the deleted item.
     * @type {string}
     * @memberof Deleted
     */
    'state'?: string;
}
/**
 * The drive represents a space on the storage.
 * @export
 * @interface Drive
 */
export interface Drive {
    /**
     * The unique idenfier for this drive.
     * @type {string}
     * @memberof Drive
     */
    'id'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     * @type {string}
     * @memberof Drive
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'eTag'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     * @type {string}
     * @memberof Drive
     */
    'name': string;
    /**
     * 
     * @type {ItemReference}
     * @memberof Drive
     */
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'webUrl'?: string;
    /**
     * Describes the type of drive represented by this resource. Values are \"personal\" for users home spaces, \"project\", \"virtual\" or \"share\". Read-only.
     * @type {string}
     * @memberof Drive
     */
    'driveType'?: string;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     * @type {string}
     * @memberof Drive
     */
    'driveAlias'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'owner'?: IdentitySet;
    /**
     * 
     * @type {Quota}
     * @memberof Drive
     */
    'quota'?: Quota;
    /**
     * All items contained in the drive. Read-only. Nullable.
     * @type {Array<DriveItem>}
     * @memberof Drive
     */
    'items'?: Array<DriveItem>;
    /**
     * 
     * @type {DriveItem}
     * @memberof Drive
     */
    'root'?: DriveItem;
    /**
     * A collection of special drive resources.
     * @type {Array<DriveItem>}
     * @memberof Drive
     */
    'special'?: Array<DriveItem>;
}
/**
 * Represents a resource inside a drive. Read-only.
 * @export
 * @interface DriveItem
 */
export interface DriveItem {
    /**
     * Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'id'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveItem
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     * @type {string}
     * @memberof DriveItem
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'eTag'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveItem
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     * @type {string}
     * @memberof DriveItem
     */
    'name'?: string;
    /**
     * 
     * @type {ItemReference}
     * @memberof DriveItem
     */
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'webUrl'?: string;
    /**
     * The content stream, if the item represents a file.
     * @type {string}
     * @memberof DriveItem
     */
    'content'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'cTag'?: string;
    /**
     * 
     * @type {Deleted}
     * @memberof DriveItem
     */
    'deleted'?: Deleted;
    /**
     * 
     * @type {OpenGraphFile}
     * @memberof DriveItem
     */
    'file'?: OpenGraphFile;
    /**
     * 
     * @type {FileSystemInfo}
     * @memberof DriveItem
     */
    'fileSystemInfo'?: FileSystemInfo;
    /**
     * 
     * @type {Folder}
     * @memberof DriveItem
     */
    'folder'?: Folder;
    /**
     * 
     * @type {Image}
     * @memberof DriveItem
     */
    'image'?: Image;
    /**
     * 
     * @type {Photo}
     * @memberof DriveItem
     */
    'photo'?: Photo;
    /**
     * 
     * @type {GeoCoordinates}
     * @memberof DriveItem
     */
    'location'?: GeoCoordinates;
    /**
     * Collection containing ThumbnailSet objects associated with the item. Read-only. Nullable.
     * @type {Array<ThumbnailSet>}
     * @memberof DriveItem
     */
    'thumbnails'?: Array<ThumbnailSet>;
    /**
     * If this property is non-null, it indicates that the driveItem is the top-most driveItem in the drive.
     * @type {object}
     * @memberof DriveItem
     */
    'root'?: object;
    /**
     * 
     * @type {Trash}
     * @memberof DriveItem
     */
    'trash'?: Trash;
    /**
     * 
     * @type {SpecialFolder}
     * @memberof DriveItem
     */
    'specialFolder'?: SpecialFolder;
    /**
     * 
     * @type {RemoteItem}
     * @memberof DriveItem
     */
    'remoteItem'?: RemoteItem;
    /**
     * Size of the item in bytes. Read-only.
     * @type {number}
     * @memberof DriveItem
     */
    'size'?: number;
    /**
     * WebDAV compatible URL for the item. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'webDavUrl'?: string;
    /**
     * Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.
     * @type {Array<DriveItem>}
     * @memberof DriveItem
     */
    'children'?: Array<DriveItem>;
    /**
     * The set of permissions for the item. Read-only. Nullable.
     * @type {Array<Permission>}
     * @memberof DriveItem
     */
    'permissions'?: Array<Permission>;
    /**
     * 
     * @type {Audio}
     * @memberof DriveItem
     */
    'audio'?: Audio;
    /**
     * 
     * @type {Video}
     * @memberof DriveItem
     */
    'video'?: Video;
    /**
     * Indicates if the item is synchronized with the underlying storage provider. Read-only.
     * @type {boolean}
     * @memberof DriveItem
     */
    '@client.synchronize'?: boolean;
    /**
     * Properties or facets (see UI.Facet) annotated with this term will not be rendered if the annotation evaluates to true. Users can set this to hide permissons.
     * @type {boolean}
     * @memberof DriveItem
     */
    '@UI.Hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface DriveItemCreateLink
 */
export interface DriveItemCreateLink {
    /**
     * 
     * @type {SharingLinkType}
     * @memberof DriveItemCreateLink
     */
    'type'?: SharingLinkType;
    /**
     * Optional. A String with format of yyyy-MM-ddTHH:mm:ssZ of DateTime indicates the expiration time of the permission.
     * @type {string}
     * @memberof DriveItemCreateLink
     */
    'expirationDateTime'?: string;
    /**
     * Optional.The password of the sharing link that is set by the creator.
     * @type {string}
     * @memberof DriveItemCreateLink
     */
    'password'?: string;
    /**
     * Provides a user-visible display name of the link. Optional. Libregraph only.
     * @type {string}
     * @memberof DriveItemCreateLink
     */
    'displayName'?: string;
    /**
     * The quicklink property can be assigned to only one link per resource. A quicklink can be used in the clients to provide a one-click copy to clipboard action. Optional. Libregraph only.
     * @type {boolean}
     * @memberof DriveItemCreateLink
     */
    '@libre.graph.quickLink'?: boolean;
}


/**
 * 
 * @export
 * @interface DriveItemInvite
 */
export interface DriveItemInvite {
    /**
     * A collection of recipients who will receive access and the sharing invitation. Currently, only internal users or gorups are supported.
     * @type {Array<DriveRecipient>}
     * @memberof DriveItemInvite
     */
    'recipients'?: Array<DriveRecipient>;
    /**
     * Specifies the roles that are to be granted to the recipients of the sharing invitation.
     * @type {Array<string>}
     * @memberof DriveItemInvite
     */
    'roles'?: Array<string>;
    /**
     * Specifies the actions that are to be granted to the recipients of the sharing invitation, in effect creating a custom role.
     * @type {Array<string>}
     * @memberof DriveItemInvite
     */
    '@libre.graph.permissions.actions'?: Array<string>;
    /**
     * Specifies the dateTime after which the permission expires.
     * @type {string}
     * @memberof DriveItemInvite
     */
    'expirationDateTime'?: string;
}
/**
 * Represents a person, group, or other recipient to share a drive item with using the invite action.  When using invite to add permissions, the `driveRecipient` object would specify the `email`, `alias`, or `objectId` of the recipient. Only one of these values is required; multiple values are not accepted. 
 * @export
 * @interface DriveRecipient
 */
export interface DriveRecipient {
    /**
     * The unique identifier for the recipient in the directory.
     * @type {string}
     * @memberof DriveRecipient
     */
    'objectId'?: string;
    /**
     * When the recipient is referenced by objectId this annotation is used to differentiate `user` and `group` recipients.
     * @type {string}
     * @memberof DriveRecipient
     */
    '@libre.graph.recipient.type'?: string;
}
/**
 * The drive represents an update to a space on the storage.
 * @export
 * @interface DriveUpdate
 */
export interface DriveUpdate {
    /**
     * The unique idenfier for this drive.
     * @type {string}
     * @memberof DriveUpdate
     */
    'id'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveUpdate
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof DriveUpdate
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     * @type {string}
     * @memberof DriveUpdate
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof DriveUpdate
     */
    'eTag'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveUpdate
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof DriveUpdate
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     * @type {string}
     * @memberof DriveUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {ItemReference}
     * @memberof DriveUpdate
     */
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof DriveUpdate
     */
    'webUrl'?: string;
    /**
     * Describes the type of drive represented by this resource. Values are \"personal\" for users home spaces, \"project\", \"virtual\" or \"share\". Read-only.
     * @type {string}
     * @memberof DriveUpdate
     */
    'driveType'?: string;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     * @type {string}
     * @memberof DriveUpdate
     */
    'driveAlias'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveUpdate
     */
    'owner'?: IdentitySet;
    /**
     * 
     * @type {Quota}
     * @memberof DriveUpdate
     */
    'quota'?: Quota;
    /**
     * All items contained in the drive. Read-only. Nullable.
     * @type {Array<DriveItem>}
     * @memberof DriveUpdate
     */
    'items'?: Array<DriveItem>;
    /**
     * 
     * @type {DriveItem}
     * @memberof DriveUpdate
     */
    'root'?: DriveItem;
    /**
     * A collection of special drive resources.
     * @type {Array<DriveItem>}
     * @memberof DriveUpdate
     */
    'special'?: Array<DriveItem>;
}
/**
 * And extension of group representing a class or course
 * @export
 * @interface EducationClass
 */
export interface EducationClass {
    /**
     * Read-only.
     * @type {string}
     * @memberof EducationClass
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     * @type {string}
     * @memberof EducationClass
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     * @type {string}
     * @memberof EducationClass
     */
    'displayName': string;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     * @type {Array<User>}
     * @memberof EducationClass
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     * @type {Set<string>}
     * @memberof EducationClass
     */
    'members@odata.bind'?: Set<string>;
    /**
     * Classification of the group, i.e. \"class\" or \"course\"
     * @type {string}
     * @memberof EducationClass
     */
    'classification': EducationClassClassificationEnum;
    /**
     * An external unique ID for the class
     * @type {string}
     * @memberof EducationClass
     */
    'externalId'?: string;
}

export const EducationClassClassificationEnum = {
    Class: 'class',
    Course: 'course'
} as const;

export type EducationClassClassificationEnum = typeof EducationClassClassificationEnum[keyof typeof EducationClassClassificationEnum];

/**
 * Represents a school
 * @export
 * @interface EducationSchool
 */
export interface EducationSchool {
    /**
     * The unique idenfier for an entity. Read-only.
     * @type {string}
     * @memberof EducationSchool
     */
    'id'?: string;
    /**
     * The organization name
     * @type {string}
     * @memberof EducationSchool
     */
    'displayName'?: string;
    /**
     * School number
     * @type {string}
     * @memberof EducationSchool
     */
    'schoolNumber'?: string;
    /**
     * Date and time at which the service for this organization is scheduled to be terminated
     * @type {string}
     * @memberof EducationSchool
     */
    'terminationDate'?: string | null;
}
/**
 * And extension of user with education specific attributes
 * @export
 * @interface EducationUser
 */
export interface EducationUser {
    /**
     * Read-only.
     * @type {string}
     * @memberof EducationUser
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     * @type {boolean}
     * @memberof EducationUser
     */
    'accountEnabled'?: boolean;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     * @type {string}
     * @memberof EducationUser
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     * @type {Array<Drive>}
     * @memberof EducationUser
     */
    'drives'?: Array<Drive>;
    /**
     * 
     * @type {Drive}
     * @memberof EducationUser
     */
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     * @type {Array<ObjectIdentity>}
     * @memberof EducationUser
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     * @type {Array<Group>}
     * @memberof EducationUser
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory. Read-only.
     * @type {string}
     * @memberof EducationUser
     */
    'onPremisesSamAccountName'?: string;
    /**
     * 
     * @type {PasswordProfile}
     * @memberof EducationUser
     */
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'givenName'?: string;
    /**
     * The user`s default role. Such as \"student\" or \"teacher\"
     * @type {string}
     * @memberof EducationUser
     */
    'primaryRole'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, or \"Guest\" for guest users.
     * @type {string}
     * @memberof EducationUser
     */
    'userType'?: string;
}
/**
 * 
 * @export
 * @interface EducationUserReference
 */
export interface EducationUserReference {
    /**
     * 
     * @type {string}
     * @memberof EducationUserReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface ExportPersonalDataRequest
 */
export interface ExportPersonalDataRequest {
    /**
     * the path where the file should be created in the users personal space
     * @type {string}
     * @memberof ExportPersonalDataRequest
     */
    'storageLocation'?: string;
}
/**
 * File system information on client. Read-write.
 * @export
 * @interface FileSystemInfo
 */
export interface FileSystemInfo {
    /**
     * The UTC date and time the file was created on a client.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'createdDateTime'?: string;
    /**
     * The UTC date and time the file was last accessed. Available for the recent file list only.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'lastAccessedDateTime'?: string;
    /**
     * The UTC date and time the file was last modified on a client.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'lastModifiedDateTime'?: string;
}
/**
 * Folder metadata, if the item is a folder. Read-only.
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * Number of children contained immediately within this container.
     * @type {number}
     * @memberof Folder
     */
    'childCount'?: number;
    /**
     * 
     * @type {FolderView}
     * @memberof Folder
     */
    'view'?: FolderView;
}
/**
 * A collection of properties defining the recommended view for the folder.
 * @export
 * @interface FolderView
 */
export interface FolderView {
    /**
     * The method by which the folder should be sorted.
     * @type {string}
     * @memberof FolderView
     */
    'sortBy'?: string;
    /**
     * If true, indicates that items should be sorted in descending order. Otherwise, items should be sorted ascending.
     * @type {string}
     * @memberof FolderView
     */
    'sortOrder'?: string;
    /**
     * The type of view that should be used to represent the folder.
     * @type {string}
     * @memberof FolderView
     */
    'viewType'?: string;
}
/**
 * The GeoCoordinates resource provides geographic coordinates and elevation of a location based on metadata contained within the file. If a DriveItem has a non-null location facet, the item represents a file with a known location assocaited with it. 
 * @export
 * @interface GeoCoordinates
 */
export interface GeoCoordinates {
    /**
     * The altitude (height), in feet, above sea level for the item. Read-only.
     * @type {number}
     * @memberof GeoCoordinates
     */
    'altitude'?: number;
    /**
     * The latitude, in decimal, for the item. Read-only.
     * @type {number}
     * @memberof GeoCoordinates
     */
    'latitude'?: number;
    /**
     * The longitude, in decimal, for the item. Read-only.
     * @type {number}
     * @memberof GeoCoordinates
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Read-only.
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     * @type {string}
     * @memberof Group
     */
    'displayName'?: string;
    /**
     * Specifies the group types. In MS Graph a group can have multiple types, so this is an array. In libreGraph the possible group types deviate from the MS Graph. The only group type that we currently support is \"ReadOnly\", which is set for groups that cannot be modified on the current instance.
     * @type {Array<string>}
     * @memberof Group
     */
    'groupTypes'?: Array<string>;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     * @type {Array<User>}
     * @memberof Group
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     * @type {Set<string>}
     * @memberof Group
     */
    'members@odata.bind'?: Set<string>;
}
/**
 * Hashes of the file\'s binary content, if available. Read-only.
 * @export
 * @interface Hashes
 */
export interface Hashes {
    /**
     * The CRC32 value of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'crc32Hash'?: string;
    /**
     * A proprietary hash of the file that can be used to determine if the contents of the file have changed (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'quickXorHash'?: string;
    /**
     * SHA1 hash for the contents of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'sha1Hash'?: string;
    /**
     * SHA256 hash for the contents of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'sha256Hash'?: string;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * The identity\'s display name. Note that this may not always be available or up to date. For example, if a user changes their display name, the API may show the new value in a future response, but the items associated with the user won\'t show up as having changed when using delta.
     * @type {string}
     * @memberof Identity
     */
    'displayName': string;
    /**
     * Unique identifier for the identity.
     * @type {string}
     * @memberof Identity
     */
    'id'?: string;
}
/**
 * Optional. User account.
 * @export
 * @interface IdentitySet
 */
export interface IdentitySet {
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'application'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'device'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'user'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'group'?: Identity;
}
/**
 * Image metadata, if the item is an image. Read-only.
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Optional. Height of the image, in pixels. Read-only.
     * @type {number}
     * @memberof Image
     */
    'height'?: number;
    /**
     * Optional. Width of the image, in pixels. Read-only.
     * @type {number}
     * @memberof Image
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface ItemReference
 */
export interface ItemReference {
    /**
     * Unique identifier of the drive instance that contains the item. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'driveId'?: string;
    /**
     * Identifies the type of drive. See [drive][] resource for values. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'driveType'?: string;
    /**
     * Unique identifier of the item in the drive. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'id'?: string;
    /**
     * The name of the item being referenced. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'name'?: string;
    /**
     * Path that can be used to navigate to the item. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface MemberReference
 */
export interface MemberReference {
    /**
     * 
     * @type {string}
     * @memberof MemberReference
     */
    '@odata.id'?: string;
}
/**
 * Represents an identity used to sign in to a user account
 * @export
 * @interface ObjectIdentity
 */
export interface ObjectIdentity {
    /**
     * domain of the Provider issuing the identity
     * @type {string}
     * @memberof ObjectIdentity
     */
    'issuer'?: string;
    /**
     * The unique id assigned by the issuer to the account
     * @type {string}
     * @memberof ObjectIdentity
     */
    'issuerAssignedId'?: string;
}
/**
 * 
 * @export
 * @interface OdataError
 */
export interface OdataError {
    /**
     * 
     * @type {OdataErrorMain}
     * @memberof OdataError
     */
    'error': OdataErrorMain;
}
/**
 * 
 * @export
 * @interface OdataErrorDetail
 */
export interface OdataErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface OdataErrorMain
 */
export interface OdataErrorMain {
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'target'?: string;
    /**
     * 
     * @type {Array<OdataErrorDetail>}
     * @memberof OdataErrorMain
     */
    'details'?: Array<OdataErrorDetail>;
    /**
     * The structure of this object is service-specific
     * @type {object}
     * @memberof OdataErrorMain
     */
    'innererror'?: object;
}
/**
 * File metadata, if the item is a file. Read-only.
 * @export
 * @interface OpenGraphFile
 */
export interface OpenGraphFile {
    /**
     * 
     * @type {Hashes}
     * @memberof OpenGraphFile
     */
    'hashes'?: Hashes;
    /**
     * The MIME type for the file. This is determined by logic on the server and might not be the value provided when the file was uploaded. Read-only.
     * @type {string}
     * @memberof OpenGraphFile
     */
    'mimeType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenGraphFile
     */
    'processingMetadata'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChange
 */
export interface PasswordChange {
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'newPassword': string;
}
/**
 * Password Profile associated with a user
 * @export
 * @interface PasswordProfile
 */
export interface PasswordProfile {
    /**
     * If true the user is required to change their password upon the next login
     * @type {boolean}
     * @memberof PasswordProfile
     */
    'forceChangePasswordNextSignIn'?: boolean;
    /**
     * The user\'s password
     * @type {string}
     * @memberof PasswordProfile
     */
    'password'?: string;
}
/**
 * The Permission resource provides information about a sharing permission granted for a DriveItem resource.  ### Remarks  The Permission resource uses *facets* to provide information about the kind of permission represented by the resource.  Permissions with a `link` facet represent sharing links created on the item. Sharing links contain a unique token that provides access to the item for anyone with the link.  Permissions with a `invitation` facet represent permissions added by inviting specific users or groups to have access to the file. 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * The unique identifier of the permission among all permissions on the item. Read-only.
     * @type {string}
     * @memberof Permission
     */
    'id'?: string;
    /**
     * Indicates whether the password is set for this permission. This property only appears in the response. Optional. Read-only. 
     * @type {boolean}
     * @memberof Permission
     */
    'hasPassword'?: boolean;
    /**
     * An optional expiration date which limits the permission in time.
     * @type {string}
     * @memberof Permission
     */
    'expirationDateTime'?: string | null;
    /**
     * An optional creation date. Libregraph only.
     * @type {string}
     * @memberof Permission
     */
    'createdDateTime'?: string | null;
    /**
     * 
     * @type {SharePointIdentitySet}
     * @memberof Permission
     */
    'grantedToV2'?: SharePointIdentitySet;
    /**
     * 
     * @type {SharingLink}
     * @memberof Permission
     */
    'link'?: SharingLink;
    /**
     * 
     * @type {Array<string>}
     * @memberof Permission
     */
    'roles'?: Array<string>;
    /**
     * For link type permissions, the details of the identity to whom permission was granted. This could be used to grant access to a an external user that can be identified by email, aka guest accounts.
     * @type {Array<IdentitySet>}
     * @memberof Permission
     * @deprecated
     */
    'grantedToIdentities'?: Array<IdentitySet>;
    /**
     * Use this to create a permission with custom actions.
     * @type {Array<string>}
     * @memberof Permission
     */
    '@libre.graph.permissions.actions'?: Array<string>;
    /**
     * 
     * @type {SharingInvitation}
     * @memberof Permission
     */
    'invitation'?: SharingInvitation;
}
/**
 * The photo resource provides photo and camera properties, for example, EXIF metadata, on a driveItem. 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * Camera manufacturer. Read-only.
     * @type {string}
     * @memberof Photo
     */
    'cameraMake'?: string;
    /**
     * Camera model. Read-only.
     * @type {string}
     * @memberof Photo
     */
    'cameraModel'?: string;
    /**
     * The denominator for the exposure time fraction from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'exposureDenominator'?: number;
    /**
     * The numerator for the exposure time fraction from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'exposureNumerator'?: number;
    /**
     * The F-stop value from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'fNumber'?: number;
    /**
     * The focal length from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'focalLength'?: number;
    /**
     * The ISO value from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'iso'?: number;
    /**
     * The orientation value from the camera. Read-only.
     * @type {number}
     * @memberof Photo
     */
    'orientation'?: number;
    /**
     * Represents the date and time the photo was taken. Read-only.
     * @type {string}
     * @memberof Photo
     */
    'takenDateTime'?: string;
}
/**
 * Optional. Information about the drive\'s storage space quota. Read-only.
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * Total space consumed by files in the recycle bin, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'deleted'?: number;
    /**
     * Total space remaining before reaching the quota limit, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'remaining'?: number;
    /**
     * Enumeration value that indicates the state of the storage space. Either \"normal\", \"nearing\", \"critical\" or \"exceeded\". Read-only.
     * @type {string}
     * @memberof Quota
     */
    'state'?: string;
    /**
     * Total allowed storage space, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'total'?: number;
    /**
     * Total space used, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'used'?: number;
}
/**
 * Remote item data, if the item is shared from a drive other than the one being accessed. Read-only.
 * @export
 * @interface RemoteItem
 */
export interface RemoteItem {
    /**
     * 
     * @type {IdentitySet}
     * @memberof RemoteItem
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'createdDateTime'?: string;
    /**
     * 
     * @type {OpenGraphFile}
     * @memberof RemoteItem
     */
    'file'?: OpenGraphFile;
    /**
     * 
     * @type {FileSystemInfo}
     * @memberof RemoteItem
     */
    'fileSystemInfo'?: FileSystemInfo;
    /**
     * 
     * @type {Folder}
     * @memberof RemoteItem
     */
    'folder'?: Folder;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     * @type {string}
     * @memberof RemoteItem
     */
    'driveAlias'?: string;
    /**
     * The relative path of the item in relation to its drive root.
     * @type {string}
     * @memberof RemoteItem
     */
    'path'?: string;
    /**
     * Unique identifier for the drive root of this item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'rootId'?: string;
    /**
     * Unique identifier for the remote item in its drive. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'id'?: string;
    /**
     * 
     * @type {Image}
     * @memberof RemoteItem
     */
    'image'?: Image;
    /**
     * 
     * @type {IdentitySet}
     * @memberof RemoteItem
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'lastModifiedDateTime'?: string;
    /**
     * Optional. Filename of the remote item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'name'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'eTag'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'cTag'?: string;
    /**
     * 
     * @type {ItemReference}
     * @memberof RemoteItem
     */
    'parentReference'?: ItemReference;
    /**
     * The set of permissions for the item. Read-only. Nullable.
     * @type {Array<Permission>}
     * @memberof RemoteItem
     */
    'permissions'?: Array<Permission>;
    /**
     * Size of the remote item. Read-only.
     * @type {number}
     * @memberof RemoteItem
     */
    'size'?: number;
    /**
     * 
     * @type {SpecialFolder}
     * @memberof RemoteItem
     */
    'specialFolder'?: SpecialFolder;
    /**
     * DAV compatible URL for the item.
     * @type {string}
     * @memberof RemoteItem
     */
    'webDavUrl'?: string;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'webUrl'?: string;
}
/**
 * This resource is used to represent a set of identities associated with various events for an item, such as created by or last modified by.
 * @export
 * @interface SharePointIdentitySet
 */
export interface SharePointIdentitySet {
    /**
     * 
     * @type {Identity}
     * @memberof SharePointIdentitySet
     */
    'user'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof SharePointIdentitySet
     */
    'group'?: Identity;
}
/**
 * invitation-related data items 
 * @export
 * @interface SharingInvitation
 */
export interface SharingInvitation {
    /**
     * 
     * @type {IdentitySet}
     * @memberof SharingInvitation
     */
    'invitedBy'?: IdentitySet;
}
/**
 * The `SharingLink` resource groups link-related data items into a single structure.  If a `permission` resource has a non-null `sharingLink` facet, the permission represents a sharing link (as opposed to permissions granted to a person or group). 
 * @export
 * @interface SharingLink
 */
export interface SharingLink {
    /**
     * 
     * @type {SharingLinkType}
     * @memberof SharingLink
     */
    'type'?: SharingLinkType;
    /**
     * If `true` then the user can only use this link to view the item on the web, and cannot use it to download the contents of the item.
     * @type {boolean}
     * @memberof SharingLink
     */
    'preventsDownload'?: boolean;
    /**
     * A URL that opens the item in the browser on the website.
     * @type {string}
     * @memberof SharingLink
     */
    'webUrl'?: string;
    /**
     * Provides a user-visible display name of the link. Optional. Libregraph only.
     * @type {string}
     * @memberof SharingLink
     */
    '@libre.graph.displayName'?: string;
    /**
     * The quicklink property can be assigned to only one link per resource. A quicklink can be used in the clients to provide a one-click copy to clipboard action. Optional. Libregraph only.
     * @type {boolean}
     * @memberof SharingLink
     */
    '@libre.graph.quickLink'?: boolean;
}


/**
 * The sharing link password which should be set. 
 * @export
 * @interface SharingLinkPassword
 */
export interface SharingLinkPassword {
    /**
     * Password. It may require a password policy.
     * @type {string}
     * @memberof SharingLinkPassword
     */
    'password'?: string;
}
/**
 * The type of the link created.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | internal       | Internal          | Creates an internal link without any permissions.               | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
 * @export
 * @enum {string}
 */

export const SharingLinkType = {
    Internal: 'internal',
    View: 'view',
    Upload: 'upload',
    Edit: 'edit',
    CreateOnly: 'createOnly',
    BlocksDownload: 'blocksDownload'
} as const;

export type SharingLinkType = typeof SharingLinkType[keyof typeof SharingLinkType];


/**
 * If the current item is also available as a special folder, this facet is returned. Read-only
 * @export
 * @interface SpecialFolder
 */
export interface SpecialFolder {
    /**
     * The unique identifier for this item in the /drive/special collection
     * @type {string}
     * @memberof SpecialFolder
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TagAssignment
 */
export interface TagAssignment {
    /**
     * 
     * @type {string}
     * @memberof TagAssignment
     */
    'resourceId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagAssignment
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface TagUnassignment
 */
export interface TagUnassignment {
    /**
     * 
     * @type {string}
     * @memberof TagUnassignment
     */
    'resourceId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagUnassignment
     */
    'tags': Array<string>;
}
/**
 * The thumbnail resource type represents a thumbnail for an image, video, document, or any item that has a bitmap representation. 
 * @export
 * @interface Thumbnail
 */
export interface Thumbnail {
    /**
     * The content stream for the thumbnail.
     * @type {string}
     * @memberof Thumbnail
     */
    'content'?: string;
    /**
     * The height of the thumbnail, in pixels.
     * @type {number}
     * @memberof Thumbnail
     */
    'height'?: number;
    /**
     * The unique identifier of the item that provided the thumbnail. This is only available when a folder thumbnail is requested.
     * @type {string}
     * @memberof Thumbnail
     */
    'sourceItemId'?: string;
    /**
     * The URL used to fetch the thumbnail content.
     * @type {string}
     * @memberof Thumbnail
     */
    'url'?: string;
    /**
     * The width of the thumbnail, in pixels.
     * @type {number}
     * @memberof Thumbnail
     */
    'width'?: number;
}
/**
 * The ThumbnailSet resource is a keyed collection of thumbnail resources. It\'s used to represent a set of thumbnails associated with a DriveItem. 
 * @export
 * @interface ThumbnailSet
 */
export interface ThumbnailSet {
    /**
     * The ID within the item. Read-only.
     * @type {string}
     * @memberof ThumbnailSet
     */
    'id'?: string;
    /**
     * 
     * @type {Thumbnail}
     * @memberof ThumbnailSet
     */
    'large'?: Thumbnail;
    /**
     * 
     * @type {Thumbnail}
     * @memberof ThumbnailSet
     */
    'medium'?: Thumbnail;
    /**
     * 
     * @type {Thumbnail}
     * @memberof ThumbnailSet
     */
    'small'?: Thumbnail;
    /**
     * 
     * @type {Thumbnail}
     * @memberof ThumbnailSet
     */
    'source'?: Thumbnail;
}
/**
 * Metadata for trashed drive Items
 * @export
 * @interface Trash
 */
export interface Trash {
    /**
     * 
     * @type {IdentitySet}
     * @memberof Trash
     */
    'trashedBy'?: IdentitySet;
    /**
     * The UTC date and time the folder was marked as trashed.
     * @type {string}
     * @memberof Trash
     */
    'trashedDateTime'?: string;
}
/**
 * A role definition is a collection of permissions in libre graph listing the operations that can be performed and the resources against which they can performed. 
 * @export
 * @interface UnifiedRoleDefinition
 */
export interface UnifiedRoleDefinition {
    /**
     * The description for the unifiedRoleDefinition.
     * @type {string}
     * @memberof UnifiedRoleDefinition
     */
    'description'?: string;
    /**
     * The display name for the unifiedRoleDefinition. Required. Supports $filter (`eq`, `in`).
     * @type {string}
     * @memberof UnifiedRoleDefinition
     */
    'displayName'?: string;
    /**
     * The unique identifier for the role definition. Key, not nullable, Read-only. Inherited from entity. Supports $filter (`eq`, `in`).
     * @type {string}
     * @memberof UnifiedRoleDefinition
     */
    'id'?: string;
    /**
     * List of permissions included in the role.
     * @type {Array<UnifiedRolePermission>}
     * @memberof UnifiedRoleDefinition
     */
    'rolePermissions'?: Array<UnifiedRolePermission>;
    /**
     * When presenting a list of roles the weight can be used to order them in a meaningful way. Lower weight gets higher precedence. So content with lower weight will come first. If set, weights should be non-zero, as 0 is interpreted as an unset weight. 
     * @type {number}
     * @memberof UnifiedRoleDefinition
     */
    '@libre.graph.weight'?: number;
}
/**
 * Represents a collection of allowed resource actions and the conditions that must be met for the action to be allowed. Resource actions are tasks that can be performed on a resource. For example, an application resource may support create, update, delete, and reset password actions. 
 * @export
 * @interface UnifiedRolePermission
 */
export interface UnifiedRolePermission {
    /**
     * Set of tasks that can be performed on a resource. Required.  The following is the schema for resource actions:  ```    {Namespace}/{Entity}/{PropertySet}/{Action} ```   For example: `libre.graph/applications/credentials/update`   * *{Namespace}* - The services that exposes the task. For example, all tasks in libre graph use the namespace `libre.graph`.  * *{Entity}* - The logical features or components exposed by the service in libre graph. For example, `applications`, `servicePrincipals`, or `groups`.  * *{PropertySet}* - Optional. The specific properties or aspects of the entity for which access is being granted.    For example, `libre.graph/applications/authentication/read` grants the ability to read the reply URL, logout URL,    and implicit flow property on the **application** object in libre graph. The following are reserved names for common property sets:    * `allProperties` - Designates all properties of the entity, including privileged properties.      Examples include `libre.graph/applications/allProperties/read` and `libre.graph/applications/allProperties/update`.    * `basic` - Designates common read properties but excludes privileged ones.      For example, `libre.graph/applications/basic/update` includes the ability to update standard properties like display name.    * `standard` - Designates common update properties but excludes privileged ones.      For example, `libre.graph/applications/standard/read`.  * *{Actions}* - The operations being granted. In most circumstances, permissions should be expressed in terms of CRUD operations or allTasks. Actions include:    * `create` - The ability to create a new instance of the entity.    * `read` - The ability to read a given property set (including allProperties).    * `update` - The ability to update a given property set (including allProperties).    * `delete` - The ability to delete a given entity.    * `allTasks` - Represents all CRUD operations (create, read, update, and delete).   Following the CS3 API we can represent the CS3 permissions by mapping them to driveItem properties or relations like this:  | [CS3 ResourcePermission](https://cs3org.github.io/cs3apis/#cs3.storage.provider.v1beta1.ResourcePermissions) | action | comment |  | ------------------------------------------------------------------------------------------------------------ | ------ | ------- |  | `stat` | `libre.graph/driveItem/basic/read` | `basic` because it does not include versions or trashed items |  | `get_quota` | `libre.graph/driveItem/quota/read` | read only the `quota` property |  | `get_path` | `libre.graph/driveItem/path/read` | read only the `path` property |  | `move` | `libre.graph/driveItem/path/update` | allows updating the `path` property of a CS3 resource |  | `delete` | `libre.graph/driveItem/standard/delete` | `standard` because deleting is a common update operation |  | `list_container` | `libre.graph/driveItem/children/read` | |  | `create_container` | `libre.graph/driveItem/children/create` | |  | `initiate_file_download` | `libre.graph/driveItem/content/read` | `content` is the property read when initiating a download |  | `initiate_file_upload` | `libre.graph/driveItem/upload/create` | `uploads` are a separate property. postprocessing creates the `content` |  | `add_grant` | `libre.graph/driveItem/permissions/create` | |  | `list_grant` | `libre.graph/driveItem/permissions/read` | |  | `update_grant` | `libre.graph/driveItem/permissions/update` | |  | `remove_grant` | `libre.graph/driveItem/permissions/delete` | |  | `deny_grant` | `libre.graph/driveItem/permissions/deny` | uses a non CRUD action `deny` |  | `list_file_versions` | `libre.graph/driveItem/versions/read` | `versions` is a `driveItemVersion` collection |  | `restore_file_version` | `libre.graph/driveItem/versions/update` | the only `update` action is restore |  | `list_recycle` | `libre.graph/driveItem/deleted/read` | reading a driveItem `deleted` property implies listing |  | `restore_recycle_item` | `libre.graph/driveItem/deleted/update` | the only `update` action is restore |  | `purge_recycle` | `libre.graph/driveItem/deleted/delete` | allows purging deleted `driveItems` |   Managing drives would be a different entity. A space manager role could be written as `libre.graph/drive/permission/allTasks`. 
     * @type {Array<string>}
     * @memberof UnifiedRolePermission
     */
    'allowedResourceActions'?: Array<string>;
    /**
     * Optional constraints that must be met for the permission to be effective. Not supported for custom roles.  Conditions define constraints that must be met. For example, a requirement that target resource must have a certain property. The following are the supported conditions:  * Drive: `exists @Resource.Drive` - The target resource must be a drive/space * Folder: `exists @Resource.Folder` - The target resource must be a folder * File: `exists @Resource.File` - The target resource must be a file  The following is an example of a role permission with a condition that the target resource is a folder: ```json   \"rolePermissions\": [       {           \"allowedResourceActions\": [               \"libre.graph/applications/basic/update\",               \"libre.graph/applications/credentials/update\"           ],           \"condition\":  \"exists @Resource.File\"       }   ] ``` Conditions aren\'t supported for custom roles. 
     * @type {string}
     * @memberof UnifiedRolePermission
     */
    'condition'?: string;
}
/**
 * Represents an Active Directory user object.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Read-only.
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     * @type {boolean}
     * @memberof User
     */
    'accountEnabled'?: boolean;
    /**
     * The apps and app roles which this user has been assigned.
     * @type {Array<AppRoleAssignment>}
     * @memberof User
     */
    'appRoleAssignments'?: Array<AppRoleAssignment>;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     * @type {string}
     * @memberof User
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     * @type {Array<Drive>}
     * @memberof User
     */
    'drives'?: Array<Drive>;
    /**
     * 
     * @type {Drive}
     * @memberof User
     */
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     * @type {Array<ObjectIdentity>}
     * @memberof User
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     * @type {string}
     * @memberof User
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     * @type {Array<Group>}
     * @memberof User
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory. Read-only.
     * @type {string}
     * @memberof User
     */
    'onPremisesSamAccountName'?: string;
    /**
     * 
     * @type {PasswordProfile}
     * @memberof User
     */
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     * @type {string}
     * @memberof User
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     * @type {string}
     * @memberof User
     */
    'givenName'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, or \"Guest\" for guest users.
     * @type {string}
     * @memberof User
     */
    'userType'?: string;
    /**
     * Represents the users language setting, ISO-639-1 Code
     * @type {string}
     * @memberof User
     */
    'preferredLanguage'?: string;
}
/**
 * The video resource groups video-related data items into a single structure.  If a driveItem has a non-null video facet, the item represents a video file. The properties of the video resource are populated by extracting metadata from the file. 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * Number of audio bits per sample.
     * @type {number}
     * @memberof Video
     */
    'audioBitsPerSample'?: number;
    /**
     * Number of audio channels.
     * @type {number}
     * @memberof Video
     */
    'audioChannels'?: number;
    /**
     * Name of the audio format (AAC, MP3, etc.).
     * @type {string}
     * @memberof Video
     */
    'audioFormat'?: string;
    /**
     * Number of audio samples per second.
     * @type {number}
     * @memberof Video
     */
    'audioSamplesPerSecond'?: number;
    /**
     * Bit rate of the video in bits per second.
     * @type {number}
     * @memberof Video
     */
    'bitrate'?: number;
    /**
     * Duration of the file in milliseconds.
     * @type {number}
     * @memberof Video
     */
    'duration'?: number;
    /**
     * \\\"Four character code\\\" name of the video format.
     * @type {string}
     * @memberof Video
     */
    'fourCC'?: string;
    /**
     * Frame rate of the video.
     * @type {number}
     * @memberof Video
     */
    'frameRate'?: number;
    /**
     * Height of the video, in pixels.
     * @type {number}
     * @memberof Video
     */
    'height'?: number;
    /**
     * Width of the video, in pixels.
     * @type {number}
     * @memberof Video
     */
    'width'?: number;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (kql?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/extensions/org.libregraph/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (kql !== undefined) {
                localVarQueryParameter['kql'] = kql;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(kql?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfActivities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(kql, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.getActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get activities
         * @param {string} [kql] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(kql?: string, options?: any): AxiosPromise<CollectionOfActivities> {
            return localVarFp.getActivities(kql, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get activities
     * @param {string} [kql] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivities(kql?: string, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getActivities(kql, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/v1.0/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfApplications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options?: any): AxiosPromise<CollectionOfApplications> {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary Get application by id
     * @param {string} applicationId key: id of application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DriveItemApi - axios parameter creator
 * @export
 */
export const DriveItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveItem: async (driveId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteDriveItem', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveItem: async (driveId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getDriveItem', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveItem: async (driveId: string, itemId: string, driveItem: DriveItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDriveItem', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateDriveItem', 'itemId', itemId)
            // verify required parameter 'driveItem' is not null or undefined
            assertParamExists('updateDriveItem', 'driveItem', driveItem)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriveItemApi - functional programming interface
 * @export
 */
export const DriveItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriveItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDriveItem(driveId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.deleteDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDriveItem(driveId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.getDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDriveItem(driveId, itemId, driveItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriveItemApi.updateDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DriveItemApi - factory interface
 * @export
 */
export const DriveItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriveItemApiFp(configuration)
    return {
        /**
         * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
         * @summary Delete a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDriveItem(driveId: string, itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDriveItem(driveId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a DriveItem by using its ID. 
         * @summary Get a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDriveItem(driveId: string, itemId: string, options?: any): AxiosPromise<DriveItem> {
            return localVarFp.getDriveItem(driveId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
         * @summary Update a DriveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItem} driveItem DriveItem properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: any): AxiosPromise<DriveItem> {
            return localVarFp.updateDriveItem(driveId, itemId, driveItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriveItemApi - object-oriented interface
 * @export
 * @class DriveItemApi
 * @extends {BaseAPI}
 */
export class DriveItemApi extends BaseAPI {
    /**
     * Delete a DriveItem by using its ID.  Deleting items using this method moves the items to the recycle bin instead of permanently deleting the item.  Mounted shares in the share jail are unmounted. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to false. 
     * @summary Delete a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriveItemApi
     */
    public deleteDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).deleteDriveItem(driveId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a DriveItem by using its ID. 
     * @summary Get a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriveItemApi
     */
    public getDriveItem(driveId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).getDriveItem(driveId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a DriveItem.  The request body must include a JSON object with the properties to update. Only the properties that are provided will be updated.  Currently it supports updating the following properties:  * `@UI.Hidden` - Hides the item from the UI. 
     * @summary Update a DriveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItem} driveItem DriveItem properties to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriveItemApi
     */
    public updateDriveItem(driveId: string, itemId: string, driveItem: DriveItem, options?: RawAxiosRequestConfig) {
        return DriveItemApiFp(this.configuration).updateDriveItem(driveId, itemId, driveItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesApi - axios parameter creator
 * @export
 */
export const DrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive: async (drive: Drive, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drive' is not null or undefined
            assertParamExists('createDrive', 'drive', drive)
            const localVarPath = `/v1.0/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive: async (driveId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDrive', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDrive', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive: async (driveId: string, driveUpdate: DriveUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDrive', 'driveId', driveId)
            // verify required parameter 'driveUpdate' is not null or undefined
            assertParamExists('updateDrive', 'driveUpdate', driveUpdate)
            const localVarPath = `/v1.0/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesApi - functional programming interface
 * @export
 */
export const DrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrive(drive: Drive, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrive(drive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.createDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDrive(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrive(driveId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.deleteDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrive(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDrive(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.getDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrive(driveId, driveUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesApi.updateDrive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesApi - factory interface
 * @export
 */
export const DrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive(drive: Drive, options?: any): AxiosPromise<Drive> {
            return localVarFp.createDrive(drive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive(driveId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDrive(driveId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive(driveId: string, options?: any): AxiosPromise<Drive> {
            return localVarFp.getDrive(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {DriveUpdate} driveUpdate New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: any): AxiosPromise<Drive> {
            return localVarFp.updateDrive(driveId, driveUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesApi - object-oriented interface
 * @export
 * @class DrivesApi
 * @extends {BaseAPI}
 */
export class DrivesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new drive of a specific type
     * @param {Drive} drive New space property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public createDrive(drive: Drive, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).createDrive(drive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific space
     * @param {string} driveId key: id of drive
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public deleteDrive(driveId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).deleteDrive(driveId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get drive by id
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public getDrive(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).getDrive(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the drive
     * @param {string} driveId key: id of drive
     * @param {DriveUpdate} driveUpdate New space values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public updateDrive(driveId: string, driveUpdate: DriveUpdate, options?: RawAxiosRequestConfig) {
        return DrivesApiFp(this.configuration).updateDrive(driveId, driveUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesGetDrivesApi - axios parameter creator
 * @export
 */
export const DrivesGetDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrivesBeta: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesGetDrivesApi - functional programming interface
 * @export
 */
export const DrivesGetDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesGetDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDrives($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesGetDrivesApi.listAllDrives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDrivesBeta($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesGetDrivesApi.listAllDrivesBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesGetDrivesApi - factory interface
 * @export
 */
export const DrivesGetDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesGetDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives1> {
            return localVarFp.listAllDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrivesBeta($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives1> {
            return localVarFp.listAllDrivesBeta($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesGetDrivesApi - object-oriented interface
 * @export
 * @class DrivesGetDrivesApi
 * @extends {BaseAPI}
 */
export class DrivesGetDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all available drives
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesGetDrivesApi
     */
    public listAllDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return DrivesGetDrivesApiFp(this.configuration).listAllDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesGetDrivesApi
     */
    public listAllDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return DrivesGetDrivesApiFp(this.configuration).listAllDrivesBeta($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesPermissionsApi - axios parameter creator
 * @export
 */
export const DrivesPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink: async (driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createLink', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('createLink', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/createLink`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemCreateLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (driveId: string, itemId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deletePermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deletePermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('deletePermission', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: async (driveId: string, itemId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getPermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getPermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('getPermission', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite: async (driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('invite', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('invite', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/invite`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (driveId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('listPermissions', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('listPermissions', 'itemId', itemId)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPassword: async (driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('setPermissionPassword', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('setPermissionPassword', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('setPermissionPassword', 'permId', permId)
            // verify required parameter 'sharingLinkPassword' is not null or undefined
            assertParamExists('setPermissionPassword', 'sharingLinkPassword', sharingLinkPassword)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}/setPassword`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharingLinkPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission: async (driveId: string, itemId: string, permId: string, permission: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updatePermission', 'driveId', driveId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updatePermission', 'itemId', itemId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('updatePermission', 'permId', permId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('updatePermission', 'permission', permission)
            const localVarPath = `/v1beta1/drives/{drive-id}/items/{item-id}/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"item-id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesPermissionsApi - functional programming interface
 * @export
 */
export const DrivesPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(driveId, itemId, driveItemCreateLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.createLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(driveId, itemId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.deletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(driveId, itemId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.getPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invite(driveId, itemId, driveItemInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.invite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(driveId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissionsWithAllowedValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(driveId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.setPermissionPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermission(driveId, itemId, permId, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesPermissionsApi.updatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesPermissionsApi - factory interface
 * @export
 */
export const DrivesPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesPermissionsApiFp(configuration)
    return {
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: any): AxiosPromise<Permission> {
            return localVarFp.createLink(driveId, itemId, driveItemCreateLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a DriveItem
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(driveId: string, itemId: string, permId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePermission(driveId, itemId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get sharing permission for a file or folder
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission(driveId: string, itemId: string, permId: string, options?: any): AxiosPromise<Permission> {
            return localVarFp.getPermission(driveId, itemId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: any): AxiosPromise<CollectionOfPermissions> {
            return localVarFp.invite(driveId, itemId, driveItemInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective sharing permissions on a driveItem.
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(driveId: string, itemId: string, options?: any): AxiosPromise<CollectionOfPermissionsWithAllowedValues> {
            return localVarFp.listPermissions(driveId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: any): AxiosPromise<Permission> {
            return localVarFp.setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} itemId key: id of item
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: any): AxiosPromise<Permission> {
            return localVarFp.updatePermission(driveId, itemId, permId, permission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesPermissionsApi - object-oriented interface
 * @export
 * @class DrivesPermissionsApi
 * @extends {BaseAPI}
 */
export class DrivesPermissionsApi extends BaseAPI {
    /**
     * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
     * @summary Create a sharing link for a DriveItem
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public createLink(driveId: string, itemId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).createLink(driveId, itemId, driveItemCreateLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove access to a DriveItem.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
     * @summary Remove access to a DriveItem
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public deletePermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).deletePermission(driveId, itemId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the effective sharing permission for a particular permission resource. 
     * @summary Get sharing permission for a file or folder
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public getPermission(driveId: string, itemId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).getPermission(driveId, itemId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a sharing invitation for a `driveItem`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
     * @summary Send a sharing invitation
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public invite(driveId: string, itemId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).invite(driveId, itemId, driveItemInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
     * @summary List the effective sharing permissions on a driveItem.
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public listPermissions(driveId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).listPermissions(driveId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
     * @summary Set sharing link password
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {SharingLinkPassword} sharingLinkPassword New password value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public setPermissionPassword(driveId: string, itemId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).setPermissionPassword(driveId, itemId, permId, sharingLinkPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
     * @summary Update sharing permission
     * @param {string} driveId key: id of drive
     * @param {string} itemId key: id of item
     * @param {string} permId key: id of permission
     * @param {Permission} permission New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesPermissionsApi
     */
    public updatePermission(driveId: string, itemId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig) {
        return DrivesPermissionsApiFp(this.configuration).updatePermission(driveId, itemId, permId, permission, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrivesRootApi - axios parameter creator
 * @export
 */
export const DrivesRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveItem: async (driveId: string, driveItem?: DriveItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createDriveItem', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/children`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkSpaceRoot: async (driveId: string, driveItemCreateLink?: DriveItemCreateLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('createLinkSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/createLink`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemCreateLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionSpaceRoot: async (driveId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deletePermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('deletePermissionSpaceRoot', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSpaceRoot: async (driveId: string, permId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getPermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('getPermissionSpaceRoot', 'permId', permId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getRoot', 'driveId', driveId)
            const localVarPath = `/v1.0/drives/{drive-id}/root`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteSpaceRoot: async (driveId: string, driveItemInvite?: DriveItemInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('inviteSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/invite`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driveItemInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionsSpaceRoot: async (driveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('listPermissionsSpaceRoot', 'driveId', driveId)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPasswordSpaceRoot: async (driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'permId', permId)
            // verify required parameter 'sharingLinkPassword' is not null or undefined
            assertParamExists('setPermissionPasswordSpaceRoot', 'sharingLinkPassword', sharingLinkPassword)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}/setPassword`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharingLinkPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissionSpaceRoot: async (driveId: string, permId: string, permission: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'driveId', driveId)
            // verify required parameter 'permId' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'permId', permId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('updatePermissionSpaceRoot', 'permission', permission)
            const localVarPath = `/v1beta1/drives/{drive-id}/root/permissions/{perm-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)))
                .replace(`{${"perm-id"}}`, encodeURIComponent(String(permId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesRootApi - functional programming interface
 * @export
 */
export const DrivesRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesRootApiAxiosParamCreator(configuration)
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDriveItem(driveId: string, driveItem?: DriveItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDriveItem(driveId, driveItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.createDriveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkSpaceRoot(driveId, driveItemCreateLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.createLinkSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionSpaceRoot(driveId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.deletePermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionSpaceRoot(driveId, permId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.getPermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.getRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteSpaceRoot(driveId, driveItemInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.inviteSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionsSpaceRoot(driveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPermissionsWithAllowedValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissionsSpaceRoot(driveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.listPermissionsSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.setPermissionPasswordSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermissionSpaceRoot(driveId, permId, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrivesRootApi.updatePermissionSpaceRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrivesRootApi - factory interface
 * @export
 */
export const DrivesRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesRootApiFp(configuration)
    return {
        /**
         * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
         * @summary Create a drive item
         * @param {string} driveId key: id of drive
         * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDriveItem(driveId: string, driveItem?: DriveItem, options?: any): AxiosPromise<DriveItem> {
            return localVarFp.createDriveItem(driveId, driveItem, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
         * @summary Create a sharing link for the root item of a Drive
         * @param {string} driveId key: id of drive
         * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: any): AxiosPromise<Permission> {
            return localVarFp.createLinkSpaceRoot(driveId, driveItemCreateLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
         * @summary Remove access to a Drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionSpaceRoot(driveId: string, permId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePermissionSpaceRoot(driveId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the effective sharing permission for a particular permission resource. 
         * @summary Get a single sharing permission for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSpaceRoot(driveId: string, permId: string, options?: any): AxiosPromise<Permission> {
            return localVarFp.getPermissionSpaceRoot(driveId, permId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(driveId: string, options?: any): AxiosPromise<DriveItem> {
            return localVarFp.getRoot(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
         * @summary Send a sharing invitation
         * @param {string} driveId key: id of drive
         * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: any): AxiosPromise<CollectionOfPermissions> {
            return localVarFp.inviteSpaceRoot(driveId, driveItemInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
         * @summary List the effective permissions on the root item of a drive.
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionsSpaceRoot(driveId: string, options?: any): AxiosPromise<CollectionOfPermissionsWithAllowedValues> {
            return localVarFp.listPermissionsSpaceRoot(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
         * @summary Set sharing link password for the root item of a drive
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {SharingLinkPassword} sharingLinkPassword New password value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: any): AxiosPromise<Permission> {
            return localVarFp.setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
         * @summary Update sharing permission
         * @param {string} driveId key: id of drive
         * @param {string} permId key: id of permission
         * @param {Permission} permission New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: any): AxiosPromise<Permission> {
            return localVarFp.updatePermissionSpaceRoot(driveId, permId, permission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesRootApi - object-oriented interface
 * @export
 * @class DrivesRootApi
 * @extends {BaseAPI}
 */
export class DrivesRootApi extends BaseAPI {
    /**
     * You can use the root childrens endpoint to mount a remoteItem in the share jail. The `@client.synchronize` property of the `driveItem` in the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint will change to true. 
     * @summary Create a drive item
     * @param {string} driveId key: id of drive
     * @param {DriveItem} [driveItem] In the request body, provide a JSON object with the following parameters. For mounting a share the necessary remoteItem id and permission id can be taken from the [sharedWithMe](#/me.drive/ListSharedWithMe) endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public createDriveItem(driveId: string, driveItem?: DriveItem, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).createDriveItem(driveId, driveItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use the createLink action to share a driveItem via a sharing link.  The response will be a permission object with the link facet containing the created link details.  ## Link types  For now, The following values are allowed for the type parameter.  | Value          | Display name      | Description                                                     | | -------------- | ----------------- | --------------------------------------------------------------- | | view           | View              | Creates a read-only link to the driveItem.                      | | upload         | Upload            | Creates a read-write link to the folder driveItem.              | | edit           | Edit              | Creates a read-write link to the driveItem.                     | | createOnly     | File Drop         | Creates an upload-only link to the folder driveItem.            | | blocksDownload | Secure View       | Creates a read-only link that blocks download to the driveItem. | 
     * @summary Create a sharing link for the root item of a Drive
     * @param {string} driveId key: id of drive
     * @param {DriveItemCreateLink} [driveItemCreateLink] In the request body, provide a JSON object with the following parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public createLinkSpaceRoot(driveId: string, driveItemCreateLink?: DriveItemCreateLink, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).createLinkSpaceRoot(driveId, driveItemCreateLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove access to the root item of a drive.  Only sharing permissions that are not inherited can be deleted. The `inheritedFrom` property must be `null`. 
     * @summary Remove access to a Drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public deletePermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).deletePermissionSpaceRoot(driveId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the effective sharing permission for a particular permission resource. 
     * @summary Get a single sharing permission for the root item of a drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public getPermissionSpaceRoot(driveId: string, permId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).getPermissionSpaceRoot(driveId, permId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get root from arbitrary space
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public getRoot(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).getRoot(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a sharing invitation for the root of a `drive`. A sharing invitation provides permissions to the recipients and optionally sends them an email with a sharing link.  The response will be a permission object with the grantedToV2 property containing the created grant details.  ## Roles property values For now, roles are only identified by a uuid. There are no hardcoded aliases like `read` or `write` because role actions can be completely customized. 
     * @summary Send a sharing invitation
     * @param {string} driveId key: id of drive
     * @param {DriveItemInvite} [driveItemInvite] In the request body, provide a JSON object with the following parameters. To create a custom role submit a list of actions instead of roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public inviteSpaceRoot(driveId: string, driveItemInvite?: DriveItemInvite, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).inviteSpaceRoot(driveId, driveItemInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The permissions collection includes potentially sensitive information and may not be available for every caller.  * For the owner of the item, all sharing permissions will be returned. This includes co-owners. * For a non-owner caller, only the sharing permissions that apply to the caller are returned. * Sharing permission properties that contain secrets (e.g. `webUrl`) are only returned for callers that are able to create the sharing permission.  All permission objects have an `id`. A permission representing * a link has the `link` facet filled with details. * a share has the `roles` property set and the `grantedToV2` property filled with the grant recipient details. 
     * @summary List the effective permissions on the root item of a drive.
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public listPermissionsSpaceRoot(driveId: string, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).listPermissionsSpaceRoot(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the password of a sharing permission.  Only the `password` property can be modified this way. 
     * @summary Set sharing link password for the root item of a drive
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {SharingLinkPassword} sharingLinkPassword New password value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public setPermissionPasswordSpaceRoot(driveId: string, permId: string, sharingLinkPassword: SharingLinkPassword, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).setPermissionPasswordSpaceRoot(driveId, permId, sharingLinkPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of a sharing permission by patching the permission resource.  Only the `roles`, `expirationDateTime` and `password` properties can be modified this way. 
     * @summary Update sharing permission
     * @param {string} driveId key: id of drive
     * @param {string} permId key: id of permission
     * @param {Permission} permission New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public updatePermissionSpaceRoot(driveId: string, permId: string, permission: Permission, options?: RawAxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).updatePermissionSpaceRoot(driveId, permId, permission, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationClassApi - axios parameter creator
 * @export
 */
export const EducationClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass: async (classId: string, classMemberReference: ClassMemberReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addUserToClass', 'classId', classId)
            // verify required parameter 'classMemberReference' is not null or undefined
            assertParamExists('addUserToClass', 'classMemberReference', classMemberReference)
            const localVarPath = `/v1.0/education/classes/{class-id}/members/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classMemberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass: async (educationClass: EducationClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('createClass', 'educationClass', educationClass)
            const localVarPath = `/v1.0/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClass', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass: async (classId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'userId', userId)
            const localVarPath = `/v1.0/education/classes/{class-id}/members/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getClass', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('listClassMembers', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}/members`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass: async (classId: string, educationClass: EducationClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('updateClass', 'classId', classId)
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('updateClass', 'educationClass', educationClass)
            const localVarPath = `/v1.0/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassApi - functional programming interface
 * @export
 */
export const EducationClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToClass(classId, classMemberReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.addUserToClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClass(educationClass: EducationClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClass(educationClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.createClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClass(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClass(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.deleteClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromClass(classId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.deleteUserFromClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClass(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClass(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.getClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClassMembers(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClassMembers(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.listClassMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.listClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClass(classId: string, educationClass: EducationClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClass(classId, educationClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassApi.updateClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationClassApi - factory interface
 * @export
 */
export const EducationClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToClass(classId, classMemberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass(educationClass: EducationClass, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.createClass(educationClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass(classId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass(classId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass(classId: string, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.getClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers(classId: string, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listClassMembers(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses(options?: any): AxiosPromise<CollectionOfClass> {
            return localVarFp.listClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass(classId: string, educationClass: EducationClass, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.updateClass(classId, educationClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassApi - object-oriented interface
 * @export
 * @class EducationClassApi
 * @extends {BaseAPI}
 */
export class EducationClassApi extends BaseAPI {
    /**
     * 
     * @summary Assign a user to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassMemberReference} classMemberReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).addUserToClass(classId, classMemberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new education class
     * @param {EducationClass} educationClass New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public createClass(educationClass: EducationClass, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).createClass(educationClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete education class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public deleteClass(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign from class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public deleteUserFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteUserFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get class by key
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public getClass(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).getClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public listClassMembers(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClassMembers(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list education classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public listClasses(options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a education class
     * @param {string} classId key: id or externalId of class
     * @param {EducationClass} educationClass New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public updateClass(classId: string, educationClass: EducationClass, options?: RawAxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).updateClass(classId, educationClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationClassTeachersApi - axios parameter creator
 * @export
 */
export const EducationClassTeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass: async (classId: string, classTeacherReference: ClassTeacherReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addTeacherToClass', 'classId', classId)
            // verify required parameter 'classTeacherReference' is not null or undefined
            assertParamExists('addTeacherToClass', 'classTeacherReference', classTeacherReference)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classTeacherReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass: async (classId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'userId', userId)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getTeachers', 'classId', classId)
            const localVarPath = `/v1.0/education/classes/{class-id}/teachers`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassTeachersApi - functional programming interface
 * @export
 */
export const EducationClassTeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassTeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeacherToClass(classId, classTeacherReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.addTeacherToClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeacherFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeacherFromClass(classId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.deleteTeacherFromClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationClassTeachersApi.getTeachers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationClassTeachersApi - factory interface
 * @export
 */
export const EducationClassTeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassTeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: any): AxiosPromise<void> {
            return localVarFp.addTeacherToClass(classId, classTeacherReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass(classId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeacherFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(classId: string, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.getTeachers(classId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassTeachersApi - object-oriented interface
 * @export
 * @class EducationClassTeachersApi
 * @extends {BaseAPI}
 */
export class EducationClassTeachersApi extends BaseAPI {
    /**
     * 
     * @summary Assign a teacher to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).addTeacherToClass(classId, classTeacherReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user as teacher of a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public deleteTeacherFromClass(classId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).deleteTeacherFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the teachers for a class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public getTeachers(classId: string, options?: RawAxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).getTeachers(classId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationSchoolApi - axios parameter creator
 * @export
 */
export const EducationSchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool: async (schoolId: string, classReference: ClassReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addClassToSchool', 'schoolId', schoolId)
            // verify required parameter 'classReference' is not null or undefined
            assertParamExists('addClassToSchool', 'classReference', classReference)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool: async (schoolId: string, educationUserReference: EducationUserReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addUserToSchool', 'schoolId', schoolId)
            // verify required parameter 'educationUserReference' is not null or undefined
            assertParamExists('addUserToSchool', 'educationUserReference', educationUserReference)
            const localVarPath = `/v1.0/education/schools/{school-id}/users/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUserReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool: async (educationSchool: EducationSchool, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('createSchool', 'educationSchool', educationSchool)
            const localVarPath = `/v1.0/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool: async (schoolId: string, classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'schoolId', schoolId)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'classId', classId)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes/{class-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteSchool', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool: async (schoolId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'schoolId', schoolId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'userId', userId)
            const localVarPath = `/v1.0/education/schools/{school-id}/users/{user-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('getSchool', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolClasses', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}/classes`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers: async (schoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolUsers', 'schoolId', schoolId)
            const localVarPath = `/v1.0/education/schools/{school-id}/users`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool: async (schoolId: string, educationSchool: EducationSchool, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('updateSchool', 'schoolId', schoolId)
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('updateSchool', 'educationSchool', educationSchool)
            const localVarPath = `/v1.0/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationSchoolApi - functional programming interface
 * @export
 */
export const EducationSchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationSchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClassToSchool(schoolId: string, classReference: ClassReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClassToSchool(schoolId, classReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.addClassToSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToSchool(schoolId, educationUserReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.addUserToSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchool(educationSchool: EducationSchool, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchool(educationSchool, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.createSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClassFromSchool(schoolId: string, classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClassFromSchool(schoolId, classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteClassFromSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchool(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchool(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromSchool(schoolId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromSchool(schoolId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.deleteUserFromSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchool(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.getSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolClasses(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolClasses(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchoolClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolUsers(schoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolUsers(schoolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchoolUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchools(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchools(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.listSchools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchool(schoolId: string, educationSchool: EducationSchool, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchool(schoolId, educationSchool, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationSchoolApi.updateSchool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationSchoolApi - factory interface
 * @export
 */
export const EducationSchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationSchoolApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool(schoolId: string, classReference: ClassReference, options?: any): AxiosPromise<void> {
            return localVarFp.addClassToSchool(schoolId, classReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToSchool(schoolId, educationUserReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool(educationSchool: EducationSchool, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.createSchool(educationSchool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool(schoolId: string, classId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClassFromSchool(schoolId, classId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool(schoolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool(schoolId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromSchool(schoolId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(schoolId: string, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.getSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses(schoolId: string, options?: any): AxiosPromise<CollectionOfEducationClass> {
            return localVarFp.listSchoolClasses(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers(schoolId: string, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listSchoolUsers(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools(options?: any): AxiosPromise<CollectionOfSchools> {
            return localVarFp.listSchools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool(schoolId: string, educationSchool: EducationSchool, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.updateSchool(schoolId, educationSchool, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationSchoolApi - object-oriented interface
 * @export
 * @class EducationSchoolApi
 * @extends {BaseAPI}
 */
export class EducationSchoolApi extends BaseAPI {
    /**
     * 
     * @summary Assign a class to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {ClassReference} classReference educationClass to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public addClassToSchool(schoolId: string, classReference: ClassReference, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addClassToSchool(schoolId, classReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a user to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationUserReference} educationUserReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addUserToSchool(schoolId, educationUserReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new school
     * @param {EducationSchool} educationSchool New school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public createSchool(educationSchool: EducationSchool, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).createSchool(educationSchool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign class from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} classId key: id or externalId of the class to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteClassFromSchool(schoolId: string, classId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteClassFromSchool(schoolId, classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
     * @summary Delete school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteSchool(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} userId key: id or username of the user to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteUserFromSchool(schoolId: string, userId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteUserFromSchool(schoolId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the properties of a specific school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public getSchool(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).getSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchoolClasses(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolClasses(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationUser resources associated with an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchoolUsers(schoolId: string, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolUsers(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of schools and their properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchools(options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationSchool} educationSchool New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public updateSchool(schoolId: string, educationSchool: EducationSchool, options?: RawAxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).updateSchool(schoolId, educationSchool, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EducationUserApi - axios parameter creator
 * @export
 */
export const EducationUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser: async (educationUser: EducationUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('createEducationUser', 'educationUser', educationUser)
            const localVarPath = `/v1.0/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteEducationUser', 'userId', userId)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser: async (userId: string, $expand?: Set<GetEducationUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getEducationUser', 'userId', userId)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers: async ($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser: async (userId: string, educationUser: EducationUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEducationUser', 'userId', userId)
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('updateEducationUser', 'educationUser', educationUser)
            const localVarPath = `/v1.0/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationUserApi - functional programming interface
 * @export
 */
export const EducationUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEducationUser(educationUser: EducationUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEducationUser(educationUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.createEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEducationUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEducationUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.deleteEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEducationUser(userId, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.getEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEducationUsers($orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.listEducationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEducationUser(userId: string, educationUser: EducationUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEducationUser(userId, educationUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EducationUserApi.updateEducationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EducationUserApi - factory interface
 * @export
 */
export const EducationUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser(educationUser: EducationUser, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.createEducationUser(educationUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEducationUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.getEducationUser(userId, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listEducationUsers($orderby, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser(userId: string, educationUser: EducationUser, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.updateEducationUser(userId, educationUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationUserApi - object-oriented interface
 * @export
 * @class EducationUserApi
 * @extends {BaseAPI}
 */
export class EducationUserApi extends BaseAPI {
    /**
     * 
     * @summary Add new education user
     * @param {EducationUser} educationUser New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public createEducationUser(educationUser: EducationUser, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).createEducationUser(educationUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete educationUser
     * @param {string} userId key: id or username of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public deleteEducationUser(userId: string, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).deleteEducationUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {Set<GetEducationUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public getEducationUser(userId: string, $expand?: Set<GetEducationUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).getEducationUser(userId, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from education users
     * @param {Set<ListEducationUsersOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListEducationUsersExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public listEducationUsers($orderby?: Set<ListEducationUsersOrderbyEnum>, $expand?: Set<ListEducationUsersExpandEnum>, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).listEducationUsers($orderby, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {EducationUser} educationUser New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public updateEducationUser(userId: string, educationUser: EducationUser, options?: RawAxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).updateEducationUser(userId, educationUser, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetEducationUserExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type GetEducationUserExpandEnum = typeof GetEducationUserExpandEnum[keyof typeof GetEducationUserExpandEnum];
/**
 * @export
 */
export const ListEducationUsersOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc',
    Mail: 'mail',
    MailDesc: 'mail desc',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    OnPremisesSamAccountNameDesc: 'onPremisesSamAccountName desc'
} as const;
export type ListEducationUsersOrderbyEnum = typeof ListEducationUsersOrderbyEnum[keyof typeof ListEducationUsersOrderbyEnum];
/**
 * @export
 */
export const ListEducationUsersExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type ListEducationUsersExpandEnum = typeof ListEducationUsersExpandEnum[keyof typeof ListEducationUsersExpandEnum];


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember: async (groupId: string, memberReference: MemberReference, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addMember', 'groupId', groupId)
            // verify required parameter 'memberReference' is not null or undefined
            assertParamExists('addMember', 'memberReference', memberReference)
            const localVarPath = `/v1.0/groups/{group-id}/members/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (groupId: string, directoryObjectId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteMember', 'groupId', groupId)
            // verify required parameter 'directoryObjectId' is not null or undefined
            assertParamExists('deleteMember', 'directoryObjectId', directoryObjectId)
            const localVarPath = `/v1.0/groups/{group-id}/members/{directory-object-id}/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"directory-object-id"}}`, encodeURIComponent(String(directoryObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listMembers', 'groupId', groupId)
            const localVarPath = `/v1.0/groups/{group-id}/members`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (groupId: string, group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroup', 'groupId', groupId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroup', 'group', group)
            const localVarPath = `/v1.0/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMember(groupId: string, memberReference: MemberReference, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMember(groupId, memberReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.addMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(groupId, directoryObjectId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(groupId: string, group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(groupId, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.updateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember(groupId: string, memberReference: MemberReference, options?: any): AxiosPromise<void> {
            return localVarFp.addMember(groupId, memberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(groupId: string, options?: any): AxiosPromise<CollectionOfUsers> {
            return localVarFp.listMembers(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, group: Group, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroup(groupId, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Add a member to a group
     * @param {string} groupId key: id of group
     * @param {MemberReference} memberReference Object to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addMember(groupId: string, memberReference: MemberReference, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).addMember(groupId, memberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from groups
     * @param {string} groupId key: id of group
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete member from a group
     * @param {string} groupId key: id of group
     * @param {string} directoryObjectId key: id of group member to remove
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from groups by key
     * @param {string} groupId key: id or name of group
     * @param {Set<GetGroupSelectEnum>} [$select] Select properties to be returned
     * @param {Set<GetGroupExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: string, $select?: Set<GetGroupSelectEnum>, $expand?: Set<GetGroupExpandEnum>, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(groupId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of the group\'s direct members
     * @param {string} groupId key: id or name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listMembers(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).listMembers(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in groups
     * @param {string} groupId key: id of group
     * @param {Group} group New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(groupId: string, group: Group, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(groupId, group, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGroupSelectEnum = {
    Id: 'id',
    Description: 'description',
    DisplayName: 'displayName',
    Members: 'members'
} as const;
export type GetGroupSelectEnum = typeof GetGroupSelectEnum[keyof typeof GetGroupSelectEnum];
/**
 * @export
 */
export const GetGroupExpandEnum = {
    Members: 'members'
} as const;
export type GetGroupExpandEnum = typeof GetGroupExpandEnum[keyof typeof GetGroupExpandEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/v1.0/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async ($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups($search, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: any): AxiosPromise<CollectionOfGroup> {
            return localVarFp.listGroups($search, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to groups
     * @param {Group} group New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(group: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from groups
     * @param {string} [$search] Search items by search phrases
     * @param {Set<ListGroupsOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListGroupsSelectEnum>} [$select] Select properties to be returned
     * @param {Set<ListGroupsExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroups($search?: string, $orderby?: Set<ListGroupsOrderbyEnum>, $select?: Set<ListGroupsSelectEnum>, $expand?: Set<ListGroupsExpandEnum>, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups($search, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListGroupsOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc'
} as const;
export type ListGroupsOrderbyEnum = typeof ListGroupsOrderbyEnum[keyof typeof ListGroupsOrderbyEnum];
/**
 * @export
 */
export const ListGroupsSelectEnum = {
    Id: 'id',
    Description: 'description',
    DisplayName: 'displayName',
    Mail: 'mail',
    Members: 'members'
} as const;
export type ListGroupsSelectEnum = typeof ListGroupsSelectEnum[keyof typeof ListGroupsSelectEnum];
/**
 * @export
 */
export const ListGroupsExpandEnum = {
    Members: 'members'
} as const;
export type ListGroupsExpandEnum = typeof ListGroupsExpandEnum[keyof typeof ListGroupsExpandEnum];


/**
 * MeChangepasswordApi - axios parameter creator
 * @export
 */
export const MeChangepasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword: async (passwordChange: PasswordChange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChange' is not null or undefined
            assertParamExists('changeOwnPassword', 'passwordChange', passwordChange)
            const localVarPath = `/v1.0/me/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeChangepasswordApi - functional programming interface
 * @export
 */
export const MeChangepasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeChangepasswordApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOwnPassword(passwordChange: PasswordChange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOwnPassword(passwordChange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeChangepasswordApi.changeOwnPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeChangepasswordApi - factory interface
 * @export
 */
export const MeChangepasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeChangepasswordApiFp(configuration)
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword(passwordChange: PasswordChange, options?: any): AxiosPromise<void> {
            return localVarFp.changeOwnPassword(passwordChange, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeChangepasswordApi - object-oriented interface
 * @export
 * @class MeChangepasswordApi
 * @extends {BaseAPI}
 */
export class MeChangepasswordApi extends BaseAPI {
    /**
     * 
     * @summary Chanage your own password
     * @param {PasswordChange} passwordChange Password change request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeChangepasswordApi
     */
    public changeOwnPassword(passwordChange: PasswordChange, options?: RawAxiosRequestConfig) {
        return MeChangepasswordApiFp(this.configuration).changeOwnPassword(passwordChange, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveApi - axios parameter creator
 * @export
 */
export const MeDriveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedByMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drive/sharedByMe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedWithMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drive/sharedWithMe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveApi - functional programming interface
 * @export
 */
export const MeDriveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHome(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHome(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.getHome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharedByMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharedByMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.listSharedByMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharedWithMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharedWithMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveApi.listSharedWithMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveApi - factory interface
 * @export
 */
export const MeDriveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveApiFp(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome(options?: any): AxiosPromise<Drive> {
            return localVarFp.getHome(options).then((request) => request(axios, basePath));
        },
        /**
         * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
         * @summary Get a list of driveItem objects shared by the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedByMe(options?: any): AxiosPromise<CollectionOfDriveItems1> {
            return localVarFp.listSharedByMe(options).then((request) => request(axios, basePath));
        },
        /**
         * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
         * @summary Get a list of driveItem objects shared with the owner of a drive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedWithMe(options?: any): AxiosPromise<CollectionOfDriveItems1> {
            return localVarFp.listSharedWithMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveApi - object-oriented interface
 * @export
 * @class MeDriveApi
 * @extends {BaseAPI}
 */
export class MeDriveApi extends BaseAPI {
    /**
     * 
     * @summary Get personal space for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveApi
     */
    public getHome(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).getHome(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `driveItems` returned from the `sharedByMe` method always include the `permissions` relation that indicates they are shared items. 
     * @summary Get a list of driveItem objects shared by the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveApi
     */
    public listSharedByMe(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).listSharedByMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `driveItems` returned from the `sharedWithMe` method always include the `remoteItem` facet that indicates they are items from a different drive. 
     * @summary Get a list of driveItem objects shared with the owner of a drive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveApi
     */
    public listSharedWithMe(options?: RawAxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).listSharedWithMe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveRootApi - axios parameter creator
 * @export
 */
export const MeDriveRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootApi - functional programming interface
 * @export
 */
export const MeDriveRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetRoot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetRoot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveRootApi.homeGetRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveRootApi - factory interface
 * @export
 */
export const MeDriveRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootApiFp(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot(options?: any): AxiosPromise<DriveItem> {
            return localVarFp.homeGetRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootApi - object-oriented interface
 * @export
 * @class MeDriveRootApi
 * @extends {BaseAPI}
 */
export class MeDriveRootApi extends BaseAPI {
    /**
     * 
     * @summary Get root from personal space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveRootApi
     */
    public homeGetRoot(options?: RawAxiosRequestConfig) {
        return MeDriveRootApiFp(this.configuration).homeGetRoot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDriveRootChildrenApi - axios parameter creator
 * @export
 */
export const MeDriveRootChildrenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drive/root/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootChildrenApi - functional programming interface
 * @export
 */
export const MeDriveRootChildrenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootChildrenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetChildren(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetChildren(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDriveRootChildrenApi.homeGetChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDriveRootChildrenApi - factory interface
 * @export
 */
export const MeDriveRootChildrenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootChildrenApiFp(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren(options?: any): AxiosPromise<CollectionOfDriveItems> {
            return localVarFp.homeGetChildren(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootChildrenApi - object-oriented interface
 * @export
 * @class MeDriveRootChildrenApi
 * @extends {BaseAPI}
 */
export class MeDriveRootChildrenApi extends BaseAPI {
    /**
     * 
     * @summary Get children from drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveRootChildrenApi
     */
    public homeGetChildren(options?: RawAxiosRequestConfig) {
        return MeDriveRootChildrenApiFp(this.configuration).homeGetChildren(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeDrivesApi - axios parameter creator
 * @export
 */
export const MeDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrivesBeta: async ($orderby?: string, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/me/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDrivesApi - functional programming interface
 * @export
 */
export const MeDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyDrives($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDrivesApi.listMyDrives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyDrivesBeta($orderby, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeDrivesApi.listMyDrivesBeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeDrivesApi - factory interface
 * @export
 */
export const MeDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives> {
            return localVarFp.listMyDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrivesBeta($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives> {
            return localVarFp.listMyDrivesBeta($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDrivesApi - object-oriented interface
 * @export
 * @class MeDrivesApi
 * @extends {BaseAPI}
 */
export class MeDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all drives where the current user is a regular member of
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDrivesApi
     */
    public listMyDrives($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return MeDrivesApiFp(this.configuration).listMyDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Alias for \'/v1.0/drives\', the difference is that grantedtoV2 is used and roles contain unified roles instead of cs3 roles
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDrivesApi
     */
    public listMyDrivesBeta($orderby?: string, $filter?: string, options?: RawAxiosRequestConfig) {
        return MeDrivesApiFp(this.configuration).listMyDrivesBeta($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeUserApi - axios parameter creator
 * @export
 */
export const MeUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser: async ($expand?: Set<GetOwnUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the current user
         * @param {User} [user] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnUser: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeUserApi - functional programming interface
 * @export
 */
export const MeUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnUser($expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeUserApi.getOwnUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the current user
         * @param {User} [user] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOwnUser(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOwnUser(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeUserApi.updateOwnUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeUserApi - factory interface
 * @export
 */
export const MeUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: any): AxiosPromise<User> {
            return localVarFp.getOwnUser($expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the current user
         * @param {User} [user] New user values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnUser(user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateOwnUser(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeUserApi - object-oriented interface
 * @export
 * @class MeUserApi
 * @extends {BaseAPI}
 */
export class MeUserApi extends BaseAPI {
    /**
     * 
     * @summary Get current user
     * @param {Set<GetOwnUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeUserApi
     */
    public getOwnUser($expand?: Set<GetOwnUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return MeUserApiFp(this.configuration).getOwnUser($expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the current user
     * @param {User} [user] New user values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeUserApi
     */
    public updateOwnUser(user?: User, options?: RawAxiosRequestConfig) {
        return MeUserApiFp(this.configuration).updateOwnUser(user, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetOwnUserExpandEnum = {
    MemberOf: 'memberOf'
} as const;
export type GetOwnUserExpandEnum = typeof GetOwnUserExpandEnum[keyof typeof GetOwnUserExpandEnum];


/**
 * RoleManagementApi - axios parameter creator
 * @export
 */
export const RoleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionRoleDefinition: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getPermissionRoleDefinition', 'roleId', roleId)
            const localVarPath = `/v1beta1/roleManagement/permissions/roleDefinitions/{role-id}`
                .replace(`{${"role-id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionRoleDefinitions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1beta1/roleManagement/permissions/roleDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleManagementApi - functional programming interface
 * @export
 */
export const RoleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionRoleDefinition(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedRoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionRoleDefinition(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.getPermissionRoleDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionRoleDefinitions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedRoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissionRoleDefinitions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.listPermissionRoleDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleManagementApi - factory interface
 * @export
 */
export const RoleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleManagementApiFp(configuration)
    return {
        /**
         * Read the properties and relationships of a `unifiedRoleDefinition` object. 
         * @summary Get unifiedRoleDefinition
         * @param {string} roleId key: id of roleDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionRoleDefinition(roleId: string, options?: any): AxiosPromise<UnifiedRoleDefinition> {
            return localVarFp.getPermissionRoleDefinition(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
         * @summary List roleDefinitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionRoleDefinitions(options?: any): AxiosPromise<UnifiedRoleDefinition> {
            return localVarFp.listPermissionRoleDefinitions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleManagementApi - object-oriented interface
 * @export
 * @class RoleManagementApi
 * @extends {BaseAPI}
 */
export class RoleManagementApi extends BaseAPI {
    /**
     * Read the properties and relationships of a `unifiedRoleDefinition` object. 
     * @summary Get unifiedRoleDefinition
     * @param {string} roleId key: id of roleDefinition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public getPermissionRoleDefinition(roleId: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).getPermissionRoleDefinition(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of `unifiedRoleDefinition` objects for the permissions provider. This list determines the roles that can be selected when creating sharing invites. 
     * @summary List roleDefinitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public listPermissionRoleDefinitions(options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).listPermissionRoleDefinitions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags: async (tagAssignment?: TagAssignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags: async (tagUnassignment?: TagUnassignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUnassignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTags(tagAssignment?: TagAssignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTags(tagAssignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.assignTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignTags(tagUnassignment?: TagUnassignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTags(tagUnassignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.unassignTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags(tagAssignment?: TagAssignment, options?: any): AxiosPromise<void> {
            return localVarFp.assignTags(tagAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<CollectionOfTags> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags(tagUnassignment?: TagUnassignment, options?: any): AxiosPromise<void> {
            return localVarFp.unassignTags(tagUnassignment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Assign tags to a resource
     * @param {TagAssignment} [tagAssignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public assignTags(tagAssignment?: TagAssignment, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).assignTags(tagAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all known tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign tags from a resource
     * @param {TagUnassignment} [tagUnassignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public unassignTags(tagUnassignment?: TagUnassignment, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).unassignTags(tagUnassignment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData: async (userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('exportPersonalData', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}/exportPersonalData`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportPersonalDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/v1.0/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPersonalData(userId, exportPersonalDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.exportPersonalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
         * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userId, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from users
     * @param {string} userId key: id or name of user
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary export personal data of a user
     * @param {string} userId key: id or name of user
     * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from users by key
     * @param {string} userId key: id or name of user
     * @param {Set<GetUserSelectEnum>} [$select] Select properties to be returned
     * @param {Set<GetUserExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, $select?: Set<GetUserSelectEnum>, $expand?: Set<GetUserExpandEnum>, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in users
     * @param {string} userId key: id of user
     * @param {User} user New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, user: User, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetUserSelectEnum = {
    Id: 'id',
    DisplayName: 'displayName',
    Drive: 'drive',
    Drives: 'drives',
    Mail: 'mail',
    MemberOf: 'memberOf',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    Surname: 'surname'
} as const;
export type GetUserSelectEnum = typeof GetUserSelectEnum[keyof typeof GetUserSelectEnum];
/**
 * @export
 */
export const GetUserExpandEnum = {
    Drive: 'drive',
    Drives: 'drives',
    MemberOf: 'memberOf',
    AppRoleAssignments: 'appRoleAssignments'
} as const;
export type GetUserExpandEnum = typeof GetUserExpandEnum[keyof typeof GetUserExpandEnum];


/**
 * UserAppRoleAssignmentApi - axios parameter creator
 * @export
 */
export const UserAppRoleAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments: async (userId: string, appRoleAssignment: AppRoleAssignment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignment' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'appRoleAssignment', appRoleAssignment)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appRoleAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments: async (userId: string, appRoleAssignmentId: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignmentId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'appRoleAssignmentId', appRoleAssignmentId)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments/{appRoleAssignment-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"appRoleAssignment-id"}}`, encodeURIComponent(String(appRoleAssignmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userListAppRoleAssignments', 'userId', userId)
            const localVarPath = `/v1.0/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAppRoleAssignmentApi - functional programming interface
 * @export
 */
export const UserAppRoleAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAppRoleAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppRoleAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateAppRoleAssignments(userId, appRoleAssignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userCreateAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userDeleteAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListAppRoleAssignments(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAppRoleAssignments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListAppRoleAssignments(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAppRoleAssignmentApi.userListAppRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAppRoleAssignmentApi - factory interface
 * @export
 */
export const UserAppRoleAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAppRoleAssignmentApiFp(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: any): AxiosPromise<AppRoleAssignment> {
            return localVarFp.userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments(userId: string, options?: any): AxiosPromise<CollectionOfAppRoleAssignments> {
            return localVarFp.userListAppRoleAssignments(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAppRoleAssignmentApi - object-oriented interface
 * @export
 * @class UserAppRoleAssignmentApi
 * @extends {BaseAPI}
 */
export class UserAppRoleAssignmentApi extends BaseAPI {
    /**
     * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
     * @summary Grant an appRoleAssignment to a user
     * @param {string} userId key: id of user
     * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the appRoleAssignment from a user
     * @param {string} userId key: id of user
     * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Represents the global roles a user has been granted for an application.
     * @summary Get appRoleAssignments from a user
     * @param {string} userId key: id of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userListAppRoleAssignments(userId: string, options?: RawAxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userListAppRoleAssignments(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/v1.0/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async ($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers($search, $filter, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
         * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
         * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: any): AxiosPromise<CollectionOfUser> {
            return localVarFp.listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to users
     * @param {User} user New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from users
     * @param {string} [$search] Search items by search phrases
     * @param {string} [$filter] Filter users by property values and relationship attributes
     * @param {Set<ListUsersOrderbyEnum>} [$orderby] Order items by property values
     * @param {Set<ListUsersSelectEnum>} [$select] Select properties to be returned
     * @param {Set<ListUsersExpandEnum>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers($search?: string, $filter?: string, $orderby?: Set<ListUsersOrderbyEnum>, $select?: Set<ListUsersSelectEnum>, $expand?: Set<ListUsersExpandEnum>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListUsersOrderbyEnum = {
    DisplayName: 'displayName',
    DisplayNameDesc: 'displayName desc',
    Mail: 'mail',
    MailDesc: 'mail desc',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    OnPremisesSamAccountNameDesc: 'onPremisesSamAccountName desc'
} as const;
export type ListUsersOrderbyEnum = typeof ListUsersOrderbyEnum[keyof typeof ListUsersOrderbyEnum];
/**
 * @export
 */
export const ListUsersSelectEnum = {
    Id: 'id',
    DisplayName: 'displayName',
    Mail: 'mail',
    MemberOf: 'memberOf',
    OnPremisesSamAccountName: 'onPremisesSamAccountName',
    Surname: 'surname'
} as const;
export type ListUsersSelectEnum = typeof ListUsersSelectEnum[keyof typeof ListUsersSelectEnum];
/**
 * @export
 */
export const ListUsersExpandEnum = {
    Drive: 'drive',
    Drives: 'drives',
    MemberOf: 'memberOf',
    AppRoleAssignments: 'appRoleAssignments'
} as const;
export type ListUsersExpandEnum = typeof ListUsersExpandEnum[keyof typeof ListUsersExpandEnum];


