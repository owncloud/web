/* tslint:disable */
/* eslint-disable */
/**
 * Libre Graph API
 * Libre Graph is a free API for cloud collaboration inspired by the MS Graph API.
 *
 * The version of the OpenAPI document: v1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppRole
 */
export interface AppRole {
    /**
     * Specifies whether this app role can be assigned to users and groups (by setting to [\'User\']), to other application\'s (by setting to [\'Application\'], or both (by setting to [\'User\', \'Application\']). App roles supporting assignment to other applications\' service principals are also known as application permissions. The \'Application\' value is only supported for app roles defined on application entities.
     * @type {Array<string>}
     * @memberof AppRole
     */
    'allowedMemberTypes'?: Array<string>;
    /**
     * The description for the app role. This is displayed when the app role is being assigned and, if the app role functions as an application permission, during  consent experiences.
     * @type {string}
     * @memberof AppRole
     */
    'description'?: string | null;
    /**
     * Display name for the permission that appears in the app role assignment and consent experiences.
     * @type {string}
     * @memberof AppRole
     */
    'displayName'?: string | null;
    /**
     * Unique role identifier inside the appRoles collection. When creating a new app role, a new GUID identifier must be provided.
     * @type {string}
     * @memberof AppRole
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AppRoleAssignment
 */
export interface AppRoleAssignment {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'deletedDateTime'?: string;
    /**
     * The identifier (id) for the app role which is assigned to the user. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'appRoleId': string;
    /**
     * The time when the app role assignment was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'createdDateTime'?: string | null;
    /**
     * The display name of the user, group, or service principal that was granted the app role assignment. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the user, security group, or service principal being granted the app role. Security groups with dynamic memberships are supported. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalId': string | null;
    /**
     * The type of the assigned principal. This can either be User, Group, or ServicePrincipal. Read-only.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'principalType'?: string | null;
    /**
     * The display name of the resource app\'s service principal to which the assignment is made.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'resourceDisplayName'?: string | null;
    /**
     * The unique identifier (id) for the resource service principal for which the assignment is made. Required on create.
     * @type {string}
     * @memberof AppRoleAssignment
     */
    'resourceId': string | null;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * The collection of roles defined for the application. With app role assignments, these roles can be assigned to users, groups, or service principals associated with other applications. Not nullable.
     * @type {Array<AppRole>}
     * @memberof Application
     */
    'appRoles'?: Array<AppRole>;
    /**
     * The display name for the application.
     * @type {string}
     * @memberof Application
     */
    'displayName'?: string | null;
}
/**
 * 
 * @export
 * @interface ClassMemberReference
 */
export interface ClassMemberReference {
    /**
     * 
     * @type {string}
     * @memberof ClassMemberReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface ClassReference
 */
export interface ClassReference {
    /**
     * 
     * @type {string}
     * @memberof ClassReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface ClassTeacherReference
 */
export interface ClassTeacherReference {
    /**
     * 
     * @type {string}
     * @memberof ClassTeacherReference
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfAppRoleAssignments
 */
export interface CollectionOfAppRoleAssignments {
    /**
     * 
     * @type {Array<AppRoleAssignment>}
     * @memberof CollectionOfAppRoleAssignments
     */
    'value'?: Array<AppRoleAssignment>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfAppRoleAssignments
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfApplications
 */
export interface CollectionOfApplications {
    /**
     * 
     * @type {Array<Application>}
     * @memberof CollectionOfApplications
     */
    'value'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface CollectionOfClass
 */
export interface CollectionOfClass {
    /**
     * 
     * @type {Array<EducationClass>}
     * @memberof CollectionOfClass
     */
    'value'?: Array<EducationClass>;
}
/**
 * 
 * @export
 * @interface CollectionOfDriveItems
 */
export interface CollectionOfDriveItems {
    /**
     * 
     * @type {Array<DriveItem>}
     * @memberof CollectionOfDriveItems
     */
    'value'?: Array<DriveItem>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfDriveItems
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfDrives
 */
export interface CollectionOfDrives {
    /**
     * 
     * @type {Array<Drive>}
     * @memberof CollectionOfDrives
     */
    'value'?: Array<Drive>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfDrives
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfDrives1
 */
export interface CollectionOfDrives1 {
    /**
     * 
     * @type {Array<Drive>}
     * @memberof CollectionOfDrives1
     */
    'value'?: Array<Drive>;
}
/**
 * 
 * @export
 * @interface CollectionOfEducationClass
 */
export interface CollectionOfEducationClass {
    /**
     * 
     * @type {Array<EducationClass>}
     * @memberof CollectionOfEducationClass
     */
    'value'?: Array<EducationClass>;
}
/**
 * 
 * @export
 * @interface CollectionOfEducationUser
 */
export interface CollectionOfEducationUser {
    /**
     * 
     * @type {Array<EducationUser>}
     * @memberof CollectionOfEducationUser
     */
    'value'?: Array<EducationUser>;
}
/**
 * 
 * @export
 * @interface CollectionOfEducationUser1
 */
export interface CollectionOfEducationUser1 {
    /**
     * 
     * @type {Array<EducationClass>}
     * @memberof CollectionOfEducationUser1
     */
    'value'?: Array<EducationClass>;
}
/**
 * 
 * @export
 * @interface CollectionOfGroup
 */
export interface CollectionOfGroup {
    /**
     * 
     * @type {Array<Group>}
     * @memberof CollectionOfGroup
     */
    'value'?: Array<Group>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfGroup
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfSchools
 */
export interface CollectionOfSchools {
    /**
     * 
     * @type {Array<EducationSchool>}
     * @memberof CollectionOfSchools
     */
    'value'?: Array<EducationSchool>;
}
/**
 * 
 * @export
 * @interface CollectionOfTags
 */
export interface CollectionOfTags {
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectionOfTags
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CollectionOfUser
 */
export interface CollectionOfUser {
    /**
     * 
     * @type {Array<User>}
     * @memberof CollectionOfUser
     */
    'value'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof CollectionOfUser
     */
    '@odata.nextLink'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfUsers
 */
export interface CollectionOfUsers {
    /**
     * 
     * @type {Array<User>}
     * @memberof CollectionOfUsers
     */
    'value'?: Array<User>;
}
/**
 * Information about the deleted state of the item. Read-only.
 * @export
 * @interface Deleted
 */
export interface Deleted {
    /**
     * Represents the state of the deleted item.
     * @type {string}
     * @memberof Deleted
     */
    'state'?: string;
}
/**
 * Represents a Directory object. Read-only.
 * @export
 * @interface DirectoryObject
 */
export interface DirectoryObject {
    /**
     * The unique identifier for the object. 12345678-9abc-def0-1234-56789abcde. The value of the ID property is often, but not exclusively, in the form of a GUID. The value should be treated as an opaque identifier and not based in being a GUID. Null values are not allowed. Read-only.
     * @type {string}
     * @memberof DirectoryObject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectoryObject
     */
    'deletedDateTime'?: string;
}
/**
 * The drive represents a space on the storage.
 * @export
 * @interface Drive
 */
export interface Drive {
    /**
     * The unique idenfier for this drive.
     * @type {string}
     * @memberof Drive
     */
    'id'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     * @type {string}
     * @memberof Drive
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'eTag'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     * @type {string}
     * @memberof Drive
     */
    'name': string;
    /**
     * 
     * @type {ItemReference}
     * @memberof Drive
     */
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof Drive
     */
    'webUrl'?: string;
    /**
     * Describes the type of drive represented by this resource. Values are \"personal\" for users home spaces, \"project\", \"virtual\" or \"share\". Read-only.
     * @type {string}
     * @memberof Drive
     */
    'driveType'?: string;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     * @type {string}
     * @memberof Drive
     */
    'driveAlias'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Drive
     */
    'owner'?: IdentitySet;
    /**
     * 
     * @type {Quota}
     * @memberof Drive
     */
    'quota'?: Quota;
    /**
     * All items contained in the drive. Read-only. Nullable.
     * @type {Array<DriveItem>}
     * @memberof Drive
     */
    'items'?: Array<DriveItem>;
    /**
     * 
     * @type {DriveItem}
     * @memberof Drive
     */
    'root'?: DriveItem;
    /**
     * A collection of special drive resources.
     * @type {Array<DriveItem>}
     * @memberof Drive
     */
    'special'?: Array<DriveItem>;
}
/**
 * Reprensents a resource inside a drive. Read-only.
 * @export
 * @interface DriveItem
 */
export interface DriveItem {
    /**
     * Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'id'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveItem
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'createdDateTime'?: string;
    /**
     * Provides a user-visible description of the item. Optional.
     * @type {string}
     * @memberof DriveItem
     */
    'description'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'eTag'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof DriveItem
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'lastModifiedDateTime'?: string;
    /**
     * The name of the item. Read-write.
     * @type {string}
     * @memberof DriveItem
     */
    'name'?: string;
    /**
     * 
     * @type {ItemReference}
     * @memberof DriveItem
     */
    'parentReference'?: ItemReference;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'webUrl'?: string;
    /**
     * The content stream, if the item represents a file.
     * @type {string}
     * @memberof DriveItem
     */
    'content'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'cTag'?: string;
    /**
     * 
     * @type {Deleted}
     * @memberof DriveItem
     */
    'deleted'?: Deleted;
    /**
     * 
     * @type {OpenGraphFile}
     * @memberof DriveItem
     */
    'file'?: OpenGraphFile;
    /**
     * 
     * @type {FileSystemInfo}
     * @memberof DriveItem
     */
    'fileSystemInfo'?: FileSystemInfo;
    /**
     * 
     * @type {Folder}
     * @memberof DriveItem
     */
    'folder'?: Folder;
    /**
     * 
     * @type {Image}
     * @memberof DriveItem
     */
    'image'?: Image;
    /**
     * If this property is non-null, it indicates that the driveItem is the top-most driveItem in the drive.
     * @type {object}
     * @memberof DriveItem
     */
    'root'?: object;
    /**
     * 
     * @type {Trash}
     * @memberof DriveItem
     */
    'trash'?: Trash;
    /**
     * 
     * @type {SpecialFolder}
     * @memberof DriveItem
     */
    'specialFolder'?: SpecialFolder;
    /**
     * 
     * @type {RemoteItem}
     * @memberof DriveItem
     */
    'remoteItem'?: RemoteItem;
    /**
     * Size of the item in bytes. Read-only.
     * @type {number}
     * @memberof DriveItem
     */
    'size'?: number;
    /**
     * WebDAV compatible URL for the item. Read-only.
     * @type {string}
     * @memberof DriveItem
     */
    'webDavUrl'?: string;
    /**
     * Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.
     * @type {Array<DriveItem>}
     * @memberof DriveItem
     */
    'children'?: Array<DriveItem>;
    /**
     * The set of permissions for the item. Read-only. Nullable.
     * @type {Array<Permission>}
     * @memberof DriveItem
     */
    'permissions'?: Array<Permission>;
}
/**
 * And extension of group representing a class or course
 * @export
 * @interface EducationClass
 */
export interface EducationClass {
    /**
     * Read-only.
     * @type {string}
     * @memberof EducationClass
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     * @type {string}
     * @memberof EducationClass
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     * @type {string}
     * @memberof EducationClass
     */
    'displayName': string;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     * @type {Array<User>}
     * @memberof EducationClass
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     * @type {Set<string>}
     * @memberof EducationClass
     */
    'members@odata.bind'?: Set<string>;
    /**
     * Classification of the group, i.e. \"class\" or \"course\"
     * @type {string}
     * @memberof EducationClass
     */
    'classification': EducationClassClassificationEnum;
    /**
     * An external unique ID for the class
     * @type {string}
     * @memberof EducationClass
     */
    'externalId'?: string;
}

export const EducationClassClassificationEnum = {
    Class: 'class',
    Course: 'course'
} as const;

export type EducationClassClassificationEnum = typeof EducationClassClassificationEnum[keyof typeof EducationClassClassificationEnum];

/**
 * Abstract. Represents an organization in educational context
 * @export
 * @interface EducationOrganization
 */
export interface EducationOrganization {
    /**
     * The unique idenfier for an entity. Read-only.
     * @type {string}
     * @memberof EducationOrganization
     */
    'id'?: string;
    /**
     * The organization name
     * @type {string}
     * @memberof EducationOrganization
     */
    'displayName'?: string;
}
/**
 * Represents a school
 * @export
 * @interface EducationSchool
 */
export interface EducationSchool {
    /**
     * The unique idenfier for an entity. Read-only.
     * @type {string}
     * @memberof EducationSchool
     */
    'id'?: string;
    /**
     * The organization name
     * @type {string}
     * @memberof EducationSchool
     */
    'displayName'?: string;
    /**
     * School number
     * @type {string}
     * @memberof EducationSchool
     */
    'schoolNumber'?: string;
    /**
     * Date and time at which the service for this organization is scheduled to be terminated
     * @type {string}
     * @memberof EducationSchool
     */
    'terminationDate'?: string | null;
}
/**
 * And extension of user with education specific attributes
 * @export
 * @interface EducationUser
 */
export interface EducationUser {
    /**
     * Read-only.
     * @type {string}
     * @memberof EducationUser
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     * @type {boolean}
     * @memberof EducationUser
     */
    'accountEnabled'?: boolean;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     * @type {string}
     * @memberof EducationUser
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     * @type {Array<Drive>}
     * @memberof EducationUser
     */
    'drives'?: Array<Drive>;
    /**
     * 
     * @type {Drive}
     * @memberof EducationUser
     */
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     * @type {Array<ObjectIdentity>}
     * @memberof EducationUser
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     * @type {Array<Group>}
     * @memberof EducationUser
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory. Read-only.
     * @type {string}
     * @memberof EducationUser
     */
    'onPremisesSamAccountName'?: string;
    /**
     * 
     * @type {PasswordProfile}
     * @memberof EducationUser
     */
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     * @type {string}
     * @memberof EducationUser
     */
    'givenName'?: string;
    /**
     * The user`s default role. Such as \"student\" or \"teacher\"
     * @type {string}
     * @memberof EducationUser
     */
    'primaryRole'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, or \"Guest\" for guest users.
     * @type {string}
     * @memberof EducationUser
     */
    'userType'?: string;
}
/**
 * 
 * @export
 * @interface EducationUserReference
 */
export interface EducationUserReference {
    /**
     * 
     * @type {string}
     * @memberof EducationUserReference
     */
    '@odata.id'?: string;
}
/**
 * Represents an entity.
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * The unique idenfier for an entity. Read-only.
     * @type {string}
     * @memberof Entity
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ExportPersonalDataRequest
 */
export interface ExportPersonalDataRequest {
    /**
     * the path where the file should be created in the users personal space
     * @type {string}
     * @memberof ExportPersonalDataRequest
     */
    'storageLocation'?: string;
}
/**
 * File system information on client. Read-write.
 * @export
 * @interface FileSystemInfo
 */
export interface FileSystemInfo {
    /**
     * The UTC date and time the file was created on a client.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'createdDateTime'?: string;
    /**
     * The UTC date and time the file was last accessed. Available for the recent file list only.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'lastAccessedDateTime'?: string;
    /**
     * The UTC date and time the file was last modified on a client.
     * @type {string}
     * @memberof FileSystemInfo
     */
    'lastModifiedDateTime'?: string;
}
/**
 * Folder metadata, if the item is a folder. Read-only.
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * Number of children contained immediately within this container.
     * @type {number}
     * @memberof Folder
     */
    'childCount'?: number;
    /**
     * 
     * @type {FolderView}
     * @memberof Folder
     */
    'view'?: FolderView;
}
/**
 * A collection of properties defining the recommended view for the folder.
 * @export
 * @interface FolderView
 */
export interface FolderView {
    /**
     * The method by which the folder should be sorted.
     * @type {string}
     * @memberof FolderView
     */
    'sortBy'?: string;
    /**
     * If true, indicates that items should be sorted in descending order. Otherwise, items should be sorted ascending.
     * @type {string}
     * @memberof FolderView
     */
    'sortOrder'?: string;
    /**
     * The type of view that should be used to represent the folder.
     * @type {string}
     * @memberof FolderView
     */
    'viewType'?: string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Read-only.
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * An optional description for the group. Returned by default.
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * The display name for the group. This property is required when a group is created and cannot be cleared during updates. Returned by default. Supports $search and $orderBy.
     * @type {string}
     * @memberof Group
     */
    'displayName'?: string;
    /**
     * Specifies the group types. In MS Graph a group can have multiple types, so this is an array. In libreGraph the possible group types deviate from the MS Graph. The only group type that we currently support is \"ReadOnly\", which is set for groups that cannot be modified on the current instance.
     * @type {Array<string>}
     * @memberof Group
     */
    'groupTypes'?: Array<string>;
    /**
     * Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), Nullable. Supports $expand.
     * @type {Array<User>}
     * @memberof Group
     */
    'members'?: Array<User>;
    /**
     * A list of member references to the members to be added. Up to 20 members can be added with a single request
     * @type {Set<string>}
     * @memberof Group
     */
    'members@odata.bind'?: Set<string>;
}
/**
 * Hashes of the file\'s binary content, if available. Read-only.
 * @export
 * @interface Hashes
 */
export interface Hashes {
    /**
     * The CRC32 value of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'crc32Hash'?: string;
    /**
     * A proprietary hash of the file that can be used to determine if the contents of the file have changed (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'quickXorHash'?: string;
    /**
     * SHA1 hash for the contents of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'sha1Hash'?: string;
    /**
     * SHA256 hash for the contents of the file (if available). Read-only.
     * @type {string}
     * @memberof Hashes
     */
    'sha256Hash'?: string;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * The identity\'s display name. Note that this may not always be available or up to date. For example, if a user changes their display name, the API may show the new value in a future response, but the items associated with the user won\'t show up as having changed when using delta.
     * @type {string}
     * @memberof Identity
     */
    'displayName': string;
    /**
     * Unique identifier for the identity.
     * @type {string}
     * @memberof Identity
     */
    'id'?: string;
}
/**
 * Optional. User account.
 * @export
 * @interface IdentitySet
 */
export interface IdentitySet {
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'application'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'device'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'user'?: Identity;
    /**
     * 
     * @type {Identity}
     * @memberof IdentitySet
     */
    'group'?: Identity;
}
/**
 * Image metadata, if the item is an image. Read-only.
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Optional. Height of the image, in pixels. Read-only.
     * @type {number}
     * @memberof Image
     */
    'height'?: number;
    /**
     * Optional. Width of the image, in pixels. Read-only.
     * @type {number}
     * @memberof Image
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface ItemReference
 */
export interface ItemReference {
    /**
     * Unique identifier of the drive instance that contains the item. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'driveId'?: string;
    /**
     * Identifies the type of drive. See [drive][] resource for values. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'driveType'?: string;
    /**
     * Unique identifier of the item in the drive. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'id'?: string;
    /**
     * The name of the item being referenced. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'name'?: string;
    /**
     * Path that can be used to navigate to the item. Read-only.
     * @type {string}
     * @memberof ItemReference
     */
    'path'?: string;
    /**
     * A unique identifier for a shared resource that can be accessed via the [Shares][] API.
     * @type {string}
     * @memberof ItemReference
     */
    'shareId'?: string;
}
/**
 * 
 * @export
 * @interface MemberReference
 */
export interface MemberReference {
    /**
     * 
     * @type {string}
     * @memberof MemberReference
     */
    '@odata.id'?: string;
}
/**
 * Represents an identity used to sign in to a user account
 * @export
 * @interface ObjectIdentity
 */
export interface ObjectIdentity {
    /**
     * domain of the Provider issuing the identity
     * @type {string}
     * @memberof ObjectIdentity
     */
    'issuer'?: string;
    /**
     * The unique id assigned by the issuer to the account
     * @type {string}
     * @memberof ObjectIdentity
     */
    'issuerAssignedId'?: string;
}
/**
 * 
 * @export
 * @interface OdataError
 */
export interface OdataError {
    /**
     * 
     * @type {OdataErrorMain}
     * @memberof OdataError
     */
    'error': OdataErrorMain;
}
/**
 * 
 * @export
 * @interface OdataErrorDetail
 */
export interface OdataErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorDetail
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface OdataErrorMain
 */
export interface OdataErrorMain {
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof OdataErrorMain
     */
    'target'?: string;
    /**
     * 
     * @type {Array<OdataErrorDetail>}
     * @memberof OdataErrorMain
     */
    'details'?: Array<OdataErrorDetail>;
    /**
     * The structure of this object is service-specific
     * @type {object}
     * @memberof OdataErrorMain
     */
    'innererror'?: object;
}
/**
 * File metadata, if the item is a file. Read-only.
 * @export
 * @interface OpenGraphFile
 */
export interface OpenGraphFile {
    /**
     * 
     * @type {Hashes}
     * @memberof OpenGraphFile
     */
    'hashes'?: Hashes;
    /**
     * The MIME type for the file. This is determined by logic on the server and might not be the value provided when the file was uploaded. Read-only.
     * @type {string}
     * @memberof OpenGraphFile
     */
    'mimeType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenGraphFile
     */
    'processingMetadata'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChange
 */
export interface PasswordChange {
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'newPassword': string;
}
/**
 * Password Profile associated with a user
 * @export
 * @interface PasswordProfile
 */
export interface PasswordProfile {
    /**
     * If true the user is required to change their password upon the next login
     * @type {boolean}
     * @memberof PasswordProfile
     */
    'forceChangePasswordNextSignIn'?: boolean;
    /**
     * The user\'s password
     * @type {string}
     * @memberof PasswordProfile
     */
    'password'?: string;
}
/**
 * The Permission resource provides information about a sharing permission granted for a DriveItem resource.
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * An optional expiration date which limits the permission in time.
     * @type {string}
     * @memberof Permission
     */
    'expirationDateTime'?: string;
    /**
     * 
     * @type {Array<IdentitySet>}
     * @memberof Permission
     */
    'grantedToIdentities'?: Array<IdentitySet>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Permission
     */
    'roles'?: Array<string>;
}
/**
 * Optional. Information about the drive\'s storage space quota. Read-only.
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * Total space consumed by files in the recycle bin, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'deleted'?: number;
    /**
     * Total space remaining before reaching the quota limit, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'remaining'?: number;
    /**
     * Enumeration value that indicates the state of the storage space. Either \"normal\", \"nearing\", \"critical\" or \"exceeded\". Read-only.
     * @type {string}
     * @memberof Quota
     */
    'state'?: string;
    /**
     * Total allowed storage space, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'total'?: number;
    /**
     * Total space used, in bytes. Read-only.
     * @type {number}
     * @memberof Quota
     */
    'used'?: number;
}
/**
 * Remote item data, if the item is shared from a drive other than the one being accessed. Read-only.
 * @export
 * @interface RemoteItem
 */
export interface RemoteItem {
    /**
     * 
     * @type {IdentitySet}
     * @memberof RemoteItem
     */
    'createdBy'?: IdentitySet;
    /**
     * Date and time of item creation. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'createdDateTime'?: string;
    /**
     * 
     * @type {OpenGraphFile}
     * @memberof RemoteItem
     */
    'file'?: OpenGraphFile;
    /**
     * 
     * @type {FileSystemInfo}
     * @memberof RemoteItem
     */
    'fileSystemInfo'?: FileSystemInfo;
    /**
     * 
     * @type {Folder}
     * @memberof RemoteItem
     */
    'folder'?: Folder;
    /**
     * The drive alias can be used in clients to make the urls user friendly. Example: \'personal/einstein\'. This will be used to resolve to the correct driveID.
     * @type {string}
     * @memberof RemoteItem
     */
    'driveAlias'?: string;
    /**
     * The relative path of the item in relation to its drive root.
     * @type {string}
     * @memberof RemoteItem
     */
    'path'?: string;
    /**
     * Unique identifier for the drive root of this item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'rootId'?: string;
    /**
     * Unique identifier for the remote item in its drive. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'id'?: string;
    /**
     * 
     * @type {Image}
     * @memberof RemoteItem
     */
    'image'?: Image;
    /**
     * 
     * @type {IdentitySet}
     * @memberof RemoteItem
     */
    'lastModifiedBy'?: IdentitySet;
    /**
     * Date and time the item was last modified. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'lastModifiedDateTime'?: string;
    /**
     * Optional. Filename of the remote item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'name'?: string;
    /**
     * ETag for the item. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'eTag'?: string;
    /**
     * An eTag for the content of the item. This eTag is not changed if only the metadata is changed. Note This property is not returned if the item is a folder. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'cTag'?: string;
    /**
     * 
     * @type {ItemReference}
     * @memberof RemoteItem
     */
    'parentReference'?: ItemReference;
    /**
     * 
     * @type {Shared}
     * @memberof RemoteItem
     */
    'shared'?: Shared;
    /**
     * Size of the remote item. Read-only.
     * @type {number}
     * @memberof RemoteItem
     */
    'size'?: number;
    /**
     * 
     * @type {SpecialFolder}
     * @memberof RemoteItem
     */
    'specialFolder'?: SpecialFolder;
    /**
     * DAV compatible URL for the item.
     * @type {string}
     * @memberof RemoteItem
     */
    'webDavUrl'?: string;
    /**
     * URL that displays the resource in the browser. Read-only.
     * @type {string}
     * @memberof RemoteItem
     */
    'webUrl'?: string;
}
/**
 * 
 * @export
 * @interface Shared
 */
export interface Shared {
    /**
     * 
     * @type {IdentitySet}
     * @memberof Shared
     */
    'owner'?: IdentitySet;
    /**
     * Indicates the scope of how the item is shared: anonymous, organization, or users. Read-only.
     * @type {string}
     * @memberof Shared
     */
    'scope'?: string;
    /**
     * 
     * @type {IdentitySet}
     * @memberof Shared
     */
    'sharedBy'?: IdentitySet;
    /**
     * The UTC date and time when the item was shared. Read-only.
     * @type {string}
     * @memberof Shared
     */
    'sharedDateTime'?: string;
}
/**
 * If the current item is also available as a special folder, this facet is returned. Read-only
 * @export
 * @interface SpecialFolder
 */
export interface SpecialFolder {
    /**
     * The unique identifier for this item in the /drive/special collection
     * @type {string}
     * @memberof SpecialFolder
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TagAssignment
 */
export interface TagAssignment {
    /**
     * 
     * @type {string}
     * @memberof TagAssignment
     */
    'resourceId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagAssignment
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface TagUnassignment
 */
export interface TagUnassignment {
    /**
     * 
     * @type {string}
     * @memberof TagUnassignment
     */
    'resourceId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagUnassignment
     */
    'tags': Array<string>;
}
/**
 * Metadata for trashed drive Items
 * @export
 * @interface Trash
 */
export interface Trash {
    /**
     * 
     * @type {IdentitySet}
     * @memberof Trash
     */
    'trashedBy'?: IdentitySet;
    /**
     * The UTC date and time the folder was marked as trashed.
     * @type {string}
     * @memberof Trash
     */
    'trashedDateTime'?: string;
}
/**
 * Represents an Active Directory user object.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Read-only.
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * Set to \"true\" when the account is enabled.
     * @type {boolean}
     * @memberof User
     */
    'accountEnabled'?: boolean;
    /**
     * The apps and app roles which this user has been assigned.
     * @type {Array<AppRoleAssignment>}
     * @memberof User
     */
    'appRoleAssignments'?: Array<AppRoleAssignment>;
    /**
     * The name displayed in the address book for the user. This value is usually the combination of the user\'s first name, middle initial, and last name. This property is required when a user is created and it cannot be cleared during updates. Returned by default. Supports $orderby.
     * @type {string}
     * @memberof User
     */
    'displayName'?: string;
    /**
     * A collection of drives available for this user. Read-only.
     * @type {Array<Drive>}
     * @memberof User
     */
    'drives'?: Array<Drive>;
    /**
     * 
     * @type {Drive}
     * @memberof User
     */
    'drive'?: Drive;
    /**
     * Identities associated with this account.
     * @type {Array<ObjectIdentity>}
     * @memberof User
     */
    'identities'?: Array<ObjectIdentity>;
    /**
     * The SMTP address for the user, for example, \'jeff@contoso.onowncloud.com\'. Returned by default.
     * @type {string}
     * @memberof User
     */
    'mail'?: string;
    /**
     * Groups that this user is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.
     * @type {Array<Group>}
     * @memberof User
     */
    'memberOf'?: Array<Group>;
    /**
     * Contains the on-premises SAM account name synchronized from the on-premises directory. Read-only.
     * @type {string}
     * @memberof User
     */
    'onPremisesSamAccountName'?: string;
    /**
     * 
     * @type {PasswordProfile}
     * @memberof User
     */
    'passwordProfile'?: PasswordProfile;
    /**
     * The user\'s surname (family name or last name). Returned by default.
     * @type {string}
     * @memberof User
     */
    'surname'?: string;
    /**
     * The user\'s givenName. Returned by default.
     * @type {string}
     * @memberof User
     */
    'givenName'?: string;
    /**
     * The user`s type. This can be either \"Member\" for regular user, or \"Guest\" for guest users.
     * @type {string}
     * @memberof User
     */
    'userType'?: string;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfApplications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get application by id
         * @param {string} applicationId key: id of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options?: any): AxiosPromise<CollectionOfApplications> {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary Get application by id
     * @param {string} applicationId key: id of application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DrivesApi - axios parameter creator
 * @export
 */
export const DrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive: async (drive: Drive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drive' is not null or undefined
            assertParamExists('createDrive', 'drive', drive)
            const localVarPath = `/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive: async (driveId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('deleteDrive', 'driveId', driveId)
            const localVarPath = `/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive: async (driveId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getDrive', 'driveId', driveId)
            const localVarPath = `/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {Drive} drive New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive: async (driveId: string, drive: Drive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('updateDrive', 'driveId', driveId)
            // verify required parameter 'drive' is not null or undefined
            assertParamExists('updateDrive', 'drive', drive)
            const localVarPath = `/drives/{drive-id}`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesApi - functional programming interface
 * @export
 */
export const DrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrive(drive: Drive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrive(drive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDrive(driveId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrive(driveId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrive(driveId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDrive(driveId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {Drive} drive New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDrive(driveId: string, drive: Drive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrive(driveId, drive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DrivesApi - factory interface
 * @export
 */
export const DrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new drive of a specific type
         * @param {Drive} drive New space property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrive(drive: Drive, options?: any): AxiosPromise<Drive> {
            return localVarFp.createDrive(drive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific space
         * @param {string} driveId key: id of drive
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDrive(driveId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDrive(driveId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get drive by id
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrive(driveId: string, options?: any): AxiosPromise<Drive> {
            return localVarFp.getDrive(driveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the drive
         * @param {string} driveId key: id of drive
         * @param {Drive} drive New space values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDrive(driveId: string, drive: Drive, options?: any): AxiosPromise<Drive> {
            return localVarFp.updateDrive(driveId, drive, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesApi - object-oriented interface
 * @export
 * @class DrivesApi
 * @extends {BaseAPI}
 */
export class DrivesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new drive of a specific type
     * @param {Drive} drive New space property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public createDrive(drive: Drive, options?: AxiosRequestConfig) {
        return DrivesApiFp(this.configuration).createDrive(drive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific space
     * @param {string} driveId key: id of drive
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public deleteDrive(driveId: string, ifMatch?: string, options?: AxiosRequestConfig) {
        return DrivesApiFp(this.configuration).deleteDrive(driveId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get drive by id
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public getDrive(driveId: string, options?: AxiosRequestConfig) {
        return DrivesApiFp(this.configuration).getDrive(driveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the drive
     * @param {string} driveId key: id of drive
     * @param {Drive} drive New space values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesApi
     */
    public updateDrive(driveId: string, drive: Drive, options?: AxiosRequestConfig) {
        return DrivesApiFp(this.configuration).updateDrive(driveId, drive, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DrivesGetDrivesApi - axios parameter creator
 * @export
 */
export const DrivesGetDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives: async ($orderby?: string, $filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesGetDrivesApi - functional programming interface
 * @export
 */
export const DrivesGetDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesGetDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDrives($orderby?: string, $filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDrives($orderby, $filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DrivesGetDrivesApi - factory interface
 * @export
 */
export const DrivesGetDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesGetDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all available drives
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDrives($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives1> {
            return localVarFp.listAllDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesGetDrivesApi - object-oriented interface
 * @export
 * @class DrivesGetDrivesApi
 * @extends {BaseAPI}
 */
export class DrivesGetDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all available drives
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesGetDrivesApi
     */
    public listAllDrives($orderby?: string, $filter?: string, options?: AxiosRequestConfig) {
        return DrivesGetDrivesApiFp(this.configuration).listAllDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DrivesRootApi - axios parameter creator
 * @export
 */
export const DrivesRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (driveId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driveId' is not null or undefined
            assertParamExists('getRoot', 'driveId', driveId)
            const localVarPath = `/drives/{drive-id}/root`
                .replace(`{${"drive-id"}}`, encodeURIComponent(String(driveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrivesRootApi - functional programming interface
 * @export
 */
export const DrivesRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrivesRootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(driveId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(driveId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DrivesRootApi - factory interface
 * @export
 */
export const DrivesRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrivesRootApiFp(configuration)
    return {
        /**
         * 
         * @summary Get root from arbitrary space
         * @param {string} driveId key: id of drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(driveId: string, options?: any): AxiosPromise<DriveItem> {
            return localVarFp.getRoot(driveId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrivesRootApi - object-oriented interface
 * @export
 * @class DrivesRootApi
 * @extends {BaseAPI}
 */
export class DrivesRootApi extends BaseAPI {
    /**
     * 
     * @summary Get root from arbitrary space
     * @param {string} driveId key: id of drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrivesRootApi
     */
    public getRoot(driveId: string, options?: AxiosRequestConfig) {
        return DrivesRootApiFp(this.configuration).getRoot(driveId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EducationClassApi - axios parameter creator
 * @export
 */
export const EducationClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass: async (classId: string, classMemberReference: ClassMemberReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addUserToClass', 'classId', classId)
            // verify required parameter 'classMemberReference' is not null or undefined
            assertParamExists('addUserToClass', 'classMemberReference', classMemberReference)
            const localVarPath = `/education/classes/{class-id}/members/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classMemberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass: async (educationClass: EducationClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('createClass', 'educationClass', educationClass)
            const localVarPath = `/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClass', 'classId', classId)
            const localVarPath = `/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass: async (classId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromClass', 'userId', userId)
            const localVarPath = `/education/classes/{class-id}/members/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getClass', 'classId', classId)
            const localVarPath = `/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('listClassMembers', 'classId', classId)
            const localVarPath = `/education/classes/{class-id}/members`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/education/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass: async (classId: string, educationClass: EducationClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('updateClass', 'classId', classId)
            // verify required parameter 'educationClass' is not null or undefined
            assertParamExists('updateClass', 'educationClass', educationClass)
            const localVarPath = `/education/classes/{class-id}`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassApi - functional programming interface
 * @export
 */
export const EducationClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToClass(classId, classMemberReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClass(educationClass: EducationClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClass(educationClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClass(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClass(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromClass(classId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromClass(classId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClass(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClass(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClassMembers(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClassMembers(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClasses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClasses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClass(classId: string, educationClass: EducationClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClass(classId, educationClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EducationClassApi - factory interface
 * @export
 */
export const EducationClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a user to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassMemberReference} classMemberReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToClass(classId, classMemberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new education class
         * @param {EducationClass} educationClass New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass(educationClass: EducationClass, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.createClass(educationClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete education class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass(classId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign from class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromClass(classId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get class by key
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass(classId: string, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.getClass(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassMembers(classId: string, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listClassMembers(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list education classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses(options?: any): AxiosPromise<CollectionOfClass> {
            return localVarFp.listClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a education class
         * @param {string} classId key: id or externalId of class
         * @param {EducationClass} educationClass New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass(classId: string, educationClass: EducationClass, options?: any): AxiosPromise<EducationClass> {
            return localVarFp.updateClass(classId, educationClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassApi - object-oriented interface
 * @export
 * @class EducationClassApi
 * @extends {BaseAPI}
 */
export class EducationClassApi extends BaseAPI {
    /**
     * 
     * @summary Assign a user to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassMemberReference} classMemberReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public addUserToClass(classId: string, classMemberReference: ClassMemberReference, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).addUserToClass(classId, classMemberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new education class
     * @param {EducationClass} educationClass New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public createClass(educationClass: EducationClass, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).createClass(educationClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete education class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public deleteClass(classId: string, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign from class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public deleteUserFromClass(classId: string, userId: string, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).deleteUserFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get class by key
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public getClass(classId: string, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).getClass(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public listClassMembers(classId: string, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClassMembers(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list education classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public listClasses(options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).listClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a education class
     * @param {string} classId key: id or externalId of class
     * @param {EducationClass} educationClass New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassApi
     */
    public updateClass(classId: string, educationClass: EducationClass, options?: AxiosRequestConfig) {
        return EducationClassApiFp(this.configuration).updateClass(classId, educationClass, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EducationClassTeachersApi - axios parameter creator
 * @export
 */
export const EducationClassTeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass: async (classId: string, classTeacherReference: ClassTeacherReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('addTeacherToClass', 'classId', classId)
            // verify required parameter 'classTeacherReference' is not null or undefined
            assertParamExists('addTeacherToClass', 'classTeacherReference', classTeacherReference)
            const localVarPath = `/education/classes/{class-id}/teachers/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classTeacherReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass: async (classId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'classId', classId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTeacherFromClass', 'userId', userId)
            const localVarPath = `/education/classes/{class-id}/teachers/{user-id}/$ref`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getTeachers', 'classId', classId)
            const localVarPath = `/education/classes/{class-id}/teachers`
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationClassTeachersApi - functional programming interface
 * @export
 */
export const EducationClassTeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationClassTeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeacherToClass(classId, classTeacherReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeacherFromClass(classId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeacherFromClass(classId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeachers(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EducationClassTeachersApi - factory interface
 * @export
 */
export const EducationClassTeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationClassTeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a teacher to a class
         * @param {string} classId key: id or externalId of class
         * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: any): AxiosPromise<void> {
            return localVarFp.addTeacherToClass(classId, classTeacherReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user as teacher of a class
         * @param {string} classId key: id or externalId of class
         * @param {string} userId key: id or username of the user to unassign as teacher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherFromClass(classId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeacherFromClass(classId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the teachers for a class
         * @param {string} classId key: id or externalId of class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeachers(classId: string, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.getTeachers(classId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationClassTeachersApi - object-oriented interface
 * @export
 * @class EducationClassTeachersApi
 * @extends {BaseAPI}
 */
export class EducationClassTeachersApi extends BaseAPI {
    /**
     * 
     * @summary Assign a teacher to a class
     * @param {string} classId key: id or externalId of class
     * @param {ClassTeacherReference} classTeacherReference educationUser to be added as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public addTeacherToClass(classId: string, classTeacherReference: ClassTeacherReference, options?: AxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).addTeacherToClass(classId, classTeacherReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user as teacher of a class
     * @param {string} classId key: id or externalId of class
     * @param {string} userId key: id or username of the user to unassign as teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public deleteTeacherFromClass(classId: string, userId: string, options?: AxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).deleteTeacherFromClass(classId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the teachers for a class
     * @param {string} classId key: id or externalId of class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationClassTeachersApi
     */
    public getTeachers(classId: string, options?: AxiosRequestConfig) {
        return EducationClassTeachersApiFp(this.configuration).getTeachers(classId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EducationSchoolApi - axios parameter creator
 * @export
 */
export const EducationSchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool: async (schoolId: string, classReference: ClassReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addClassToSchool', 'schoolId', schoolId)
            // verify required parameter 'classReference' is not null or undefined
            assertParamExists('addClassToSchool', 'classReference', classReference)
            const localVarPath = `/education/schools/{school-id}/classes/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool: async (schoolId: string, educationUserReference: EducationUserReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('addUserToSchool', 'schoolId', schoolId)
            // verify required parameter 'educationUserReference' is not null or undefined
            assertParamExists('addUserToSchool', 'educationUserReference', educationUserReference)
            const localVarPath = `/education/schools/{school-id}/users/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUserReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool: async (educationSchool: EducationSchool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('createSchool', 'educationSchool', educationSchool)
            const localVarPath = `/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool: async (schoolId: string, classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'schoolId', schoolId)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('deleteClassFromSchool', 'classId', classId)
            const localVarPath = `/education/schools/{school-id}/classes/{class-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"class-id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool: async (schoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteSchool', 'schoolId', schoolId)
            const localVarPath = `/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool: async (schoolId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'schoolId', schoolId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserFromSchool', 'userId', userId)
            const localVarPath = `/education/schools/{school-id}/users/{user-id}/$ref`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool: async (schoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('getSchool', 'schoolId', schoolId)
            const localVarPath = `/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses: async (schoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolClasses', 'schoolId', schoolId)
            const localVarPath = `/education/schools/{school-id}/classes`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers: async (schoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('listSchoolUsers', 'schoolId', schoolId)
            const localVarPath = `/education/schools/{school-id}/users`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/education/schools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool: async (schoolId: string, educationSchool: EducationSchool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('updateSchool', 'schoolId', schoolId)
            // verify required parameter 'educationSchool' is not null or undefined
            assertParamExists('updateSchool', 'educationSchool', educationSchool)
            const localVarPath = `/education/schools/{school-id}`
                .replace(`{${"school-id"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationSchool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationSchoolApi - functional programming interface
 * @export
 */
export const EducationSchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationSchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClassToSchool(schoolId: string, classReference: ClassReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClassToSchool(schoolId, classReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToSchool(schoolId, educationUserReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchool(educationSchool: EducationSchool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchool(educationSchool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClassFromSchool(schoolId: string, classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClassFromSchool(schoolId, classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchool(schoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchool(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromSchool(schoolId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromSchool(schoolId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchool(schoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchool(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolClasses(schoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolClasses(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchoolUsers(schoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchoolUsers(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchools(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchool(schoolId: string, educationSchool: EducationSchool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchool(schoolId, educationSchool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EducationSchoolApi - factory interface
 * @export
 */
export const EducationSchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationSchoolApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a class to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {ClassReference} classReference educationClass to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassToSchool(schoolId: string, classReference: ClassReference, options?: any): AxiosPromise<void> {
            return localVarFp.addClassToSchool(schoolId, classReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a user to a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationUserReference} educationUserReference educationUser to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToSchool(schoolId, educationUserReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new school
         * @param {EducationSchool} educationSchool New school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchool(educationSchool: EducationSchool, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.createSchool(educationSchool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign class from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} classId key: id or externalId of the class to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassFromSchool(schoolId: string, classId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClassFromSchool(schoolId, classId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
         * @summary Delete school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchool(schoolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign user from a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {string} userId key: id or username of the user to unassign from school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromSchool(schoolId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromSchool(schoolId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the properties of a specific school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchool(schoolId: string, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.getSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationClass resources owned by an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolClasses(schoolId: string, options?: any): AxiosPromise<CollectionOfEducationClass> {
            return localVarFp.listSchoolClasses(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the educationUser resources associated with an educationSchool
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchoolUsers(schoolId: string, options?: any): AxiosPromise<CollectionOfEducationUser1> {
            return localVarFp.listSchoolUsers(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of schools and their properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchools(options?: any): AxiosPromise<CollectionOfSchools> {
            return localVarFp.listSchools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a school
         * @param {string} schoolId key: id or schoolNumber of school
         * @param {EducationSchool} educationSchool New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchool(schoolId: string, educationSchool: EducationSchool, options?: any): AxiosPromise<EducationSchool> {
            return localVarFp.updateSchool(schoolId, educationSchool, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationSchoolApi - object-oriented interface
 * @export
 * @class EducationSchoolApi
 * @extends {BaseAPI}
 */
export class EducationSchoolApi extends BaseAPI {
    /**
     * 
     * @summary Assign a class to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {ClassReference} classReference educationClass to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public addClassToSchool(schoolId: string, classReference: ClassReference, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addClassToSchool(schoolId, classReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a user to a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationUserReference} educationUserReference educationUser to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public addUserToSchool(schoolId: string, educationUserReference: EducationUserReference, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).addUserToSchool(schoolId, educationUserReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new school
     * @param {EducationSchool} educationSchool New school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public createSchool(educationSchool: EducationSchool, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).createSchool(educationSchool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign class from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} classId key: id or externalId of the class to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteClassFromSchool(schoolId: string, classId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteClassFromSchool(schoolId, classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a school. A school can only be delete if it has the terminationDate property set. And if that termination Date is in the past.
     * @summary Delete school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteSchool(schoolId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign user from a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {string} userId key: id or username of the user to unassign from school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public deleteUserFromSchool(schoolId: string, userId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).deleteUserFromSchool(schoolId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the properties of a specific school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public getSchool(schoolId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).getSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationClass resources owned by an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchoolClasses(schoolId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolClasses(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the educationUser resources associated with an educationSchool
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchoolUsers(schoolId: string, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchoolUsers(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of schools and their properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public listSchools(options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).listSchools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a school
     * @param {string} schoolId key: id or schoolNumber of school
     * @param {EducationSchool} educationSchool New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationSchoolApi
     */
    public updateSchool(schoolId: string, educationSchool: EducationSchool, options?: AxiosRequestConfig) {
        return EducationSchoolApiFp(this.configuration).updateSchool(schoolId, educationSchool, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EducationUserApi - axios parameter creator
 * @export
 */
export const EducationUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser: async (educationUser: EducationUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('createEducationUser', 'educationUser', educationUser)
            const localVarPath = `/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteEducationUser', 'userId', userId)
            const localVarPath = `/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser: async (userId: string, $expand?: Set<'memberOf'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getEducationUser', 'userId', userId)
            const localVarPath = `/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers: async ($orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $expand?: Set<'memberOf'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/education/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser: async (userId: string, educationUser: EducationUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEducationUser', 'userId', userId)
            // verify required parameter 'educationUser' is not null or undefined
            assertParamExists('updateEducationUser', 'educationUser', educationUser)
            const localVarPath = `/education/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(educationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EducationUserApi - functional programming interface
 * @export
 */
export const EducationUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EducationUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEducationUser(educationUser: EducationUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEducationUser(educationUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEducationUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEducationUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEducationUser(userId: string, $expand?: Set<'memberOf'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEducationUser(userId, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEducationUsers($orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $expand?: Set<'memberOf'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfEducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEducationUsers($orderby, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEducationUser(userId: string, educationUser: EducationUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EducationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEducationUser(userId, educationUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EducationUserApi - factory interface
 * @export
 */
export const EducationUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EducationUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new education user
         * @param {EducationUser} educationUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEducationUser(educationUser: EducationUser, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.createEducationUser(educationUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete educationUser
         * @param {string} userId key: id or username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEducationUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEducationUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEducationUser(userId: string, $expand?: Set<'memberOf'>, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.getEducationUser(userId, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from education users
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEducationUsers($orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $expand?: Set<'memberOf'>, options?: any): AxiosPromise<CollectionOfEducationUser> {
            return localVarFp.listEducationUsers($orderby, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of educationUser
         * @param {string} userId key: id or username of user
         * @param {EducationUser} educationUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEducationUser(userId: string, educationUser: EducationUser, options?: any): AxiosPromise<EducationUser> {
            return localVarFp.updateEducationUser(userId, educationUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EducationUserApi - object-oriented interface
 * @export
 * @class EducationUserApi
 * @extends {BaseAPI}
 */
export class EducationUserApi extends BaseAPI {
    /**
     * 
     * @summary Add new education user
     * @param {EducationUser} educationUser New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public createEducationUser(educationUser: EducationUser, options?: AxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).createEducationUser(educationUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete educationUser
     * @param {string} userId key: id or username of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public deleteEducationUser(userId: string, options?: AxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).deleteEducationUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {Set<'memberOf'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public getEducationUser(userId: string, $expand?: Set<'memberOf'>, options?: AxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).getEducationUser(userId, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from education users
     * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
     * @param {Set<'memberOf'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public listEducationUsers($orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $expand?: Set<'memberOf'>, options?: AxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).listEducationUsers($orderby, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of educationUser
     * @param {string} userId key: id or username of user
     * @param {EducationUser} educationUser New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EducationUserApi
     */
    public updateEducationUser(userId: string, educationUser: EducationUser, options?: AxiosRequestConfig) {
        return EducationUserApiFp(this.configuration).updateEducationUser(userId, educationUser, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember: async (groupId: string, memberReference: MemberReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addMember', 'groupId', groupId)
            // verify required parameter 'memberReference' is not null or undefined
            assertParamExists('addMember', 'memberReference', memberReference)
            const localVarPath = `/groups/{group-id}/members/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (groupId: string, directoryObjectId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteMember', 'groupId', groupId)
            // verify required parameter 'directoryObjectId' is not null or undefined
            assertParamExists('deleteMember', 'directoryObjectId', directoryObjectId)
            const localVarPath = `/groups/{group-id}/members/{directory-object-id}/$ref`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"directory-object-id"}}`, encodeURIComponent(String(directoryObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<'id' | 'description' | 'displayName' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, $select?: Set<'id' | 'description' | 'displayName' | 'members'>, $expand?: Set<'members'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listMembers', 'groupId', groupId)
            const localVarPath = `/groups/{group-id}/members`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (groupId: string, group: Group, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroup', 'groupId', groupId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroup', 'group', group)
            const localVarPath = `/groups/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMember(groupId: string, memberReference: MemberReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMember(groupId, memberReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(groupId, directoryObjectId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<'id' | 'description' | 'displayName' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, $select?: Set<'id' | 'description' | 'displayName' | 'members'>, $expand?: Set<'members'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(groupId: string, group: Group, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(groupId, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a member to a group
         * @param {string} groupId key: id of group
         * @param {MemberReference} memberReference Object to be added as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember(groupId: string, memberReference: MemberReference, options?: any): AxiosPromise<void> {
            return localVarFp.addMember(groupId, memberReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from groups
         * @param {string} groupId key: id of group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete member from a group
         * @param {string} groupId key: id of group
         * @param {string} directoryObjectId key: id of group member to remove
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from groups by key
         * @param {string} groupId key: id or name of group
         * @param {Set<'id' | 'description' | 'displayName' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, $select?: Set<'id' | 'description' | 'displayName' | 'members'>, $expand?: Set<'members'>, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of the group\'s direct members
         * @param {string} groupId key: id or name of group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(groupId: string, options?: any): AxiosPromise<CollectionOfUsers> {
            return localVarFp.listMembers(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in groups
         * @param {string} groupId key: id of group
         * @param {Group} group New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, group: Group, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroup(groupId, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Add a member to a group
     * @param {string} groupId key: id of group
     * @param {MemberReference} memberReference Object to be added as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addMember(groupId: string, memberReference: MemberReference, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).addMember(groupId, memberReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from groups
     * @param {string} groupId key: id of group
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupId: string, ifMatch?: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete member from a group
     * @param {string} groupId key: id of group
     * @param {string} directoryObjectId key: id of group member to remove
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteMember(groupId: string, directoryObjectId: string, ifMatch?: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteMember(groupId, directoryObjectId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from groups by key
     * @param {string} groupId key: id or name of group
     * @param {Set<'id' | 'description' | 'displayName' | 'members'>} [$select] Select properties to be returned
     * @param {Set<'members'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: string, $select?: Set<'id' | 'description' | 'displayName' | 'members'>, $expand?: Set<'members'>, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(groupId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of the group\'s direct members
     * @param {string} groupId key: id or name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listMembers(groupId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).listMembers(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in groups
     * @param {string} groupId key: id of group
     * @param {Group} group New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(groupId: string, group: Group, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(groupId, group, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: Group, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<'displayName' | 'displayName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async ($search?: string, $orderby?: Set<'displayName' | 'displayName desc'>, $select?: Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>, $expand?: Set<'members'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: Group, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<'displayName' | 'displayName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups($search?: string, $orderby?: Set<'displayName' | 'displayName desc'>, $select?: Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>, $expand?: Set<'members'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups($search, $orderby, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to groups
         * @param {Group} group New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from groups
         * @param {string} [$search] Search items by search phrases
         * @param {Set<'displayName' | 'displayName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>} [$select] Select properties to be returned
         * @param {Set<'members'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups($search?: string, $orderby?: Set<'displayName' | 'displayName desc'>, $select?: Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>, $expand?: Set<'members'>, options?: any): AxiosPromise<CollectionOfGroup> {
            return localVarFp.listGroups($search, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to groups
     * @param {Group} group New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(group: Group, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from groups
     * @param {string} [$search] Search items by search phrases
     * @param {Set<'displayName' | 'displayName desc'>} [$orderby] Order items by property values
     * @param {Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>} [$select] Select properties to be returned
     * @param {Set<'members'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroups($search?: string, $orderby?: Set<'displayName' | 'displayName desc'>, $select?: Set<'id' | 'description' | 'displayName' | 'mail' | 'members'>, $expand?: Set<'members'>, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups($search, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeChangepasswordApi - axios parameter creator
 * @export
 */
export const MeChangepasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword: async (passwordChange: PasswordChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChange' is not null or undefined
            assertParamExists('changeOwnPassword', 'passwordChange', passwordChange)
            const localVarPath = `/me/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeChangepasswordApi - functional programming interface
 * @export
 */
export const MeChangepasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeChangepasswordApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOwnPassword(passwordChange: PasswordChange, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOwnPassword(passwordChange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeChangepasswordApi - factory interface
 * @export
 */
export const MeChangepasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeChangepasswordApiFp(configuration)
    return {
        /**
         * 
         * @summary Chanage your own password
         * @param {PasswordChange} passwordChange Password change request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnPassword(passwordChange: PasswordChange, options?: any): AxiosPromise<void> {
            return localVarFp.changeOwnPassword(passwordChange, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeChangepasswordApi - object-oriented interface
 * @export
 * @class MeChangepasswordApi
 * @extends {BaseAPI}
 */
export class MeChangepasswordApi extends BaseAPI {
    /**
     * 
     * @summary Chanage your own password
     * @param {PasswordChange} passwordChange Password change request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeChangepasswordApi
     */
    public changeOwnPassword(passwordChange: PasswordChange, options?: AxiosRequestConfig) {
        return MeChangepasswordApiFp(this.configuration).changeOwnPassword(passwordChange, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeDriveApi - axios parameter creator
 * @export
 */
export const MeDriveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/drive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveApi - functional programming interface
 * @export
 */
export const MeDriveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHome(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHome(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeDriveApi - factory interface
 * @export
 */
export const MeDriveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveApiFp(configuration)
    return {
        /**
         * 
         * @summary Get personal space for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHome(options?: any): AxiosPromise<Drive> {
            return localVarFp.getHome(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveApi - object-oriented interface
 * @export
 * @class MeDriveApi
 * @extends {BaseAPI}
 */
export class MeDriveApi extends BaseAPI {
    /**
     * 
     * @summary Get personal space for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveApi
     */
    public getHome(options?: AxiosRequestConfig) {
        return MeDriveApiFp(this.configuration).getHome(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeDriveRootApi - axios parameter creator
 * @export
 */
export const MeDriveRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/drive/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootApi - functional programming interface
 * @export
 */
export const MeDriveRootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetRoot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriveItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetRoot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeDriveRootApi - factory interface
 * @export
 */
export const MeDriveRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootApiFp(configuration)
    return {
        /**
         * 
         * @summary Get root from personal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetRoot(options?: any): AxiosPromise<DriveItem> {
            return localVarFp.homeGetRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootApi - object-oriented interface
 * @export
 * @class MeDriveRootApi
 * @extends {BaseAPI}
 */
export class MeDriveRootApi extends BaseAPI {
    /**
     * 
     * @summary Get root from personal space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveRootApi
     */
    public homeGetRoot(options?: AxiosRequestConfig) {
        return MeDriveRootApiFp(this.configuration).homeGetRoot(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeDriveRootChildrenApi - axios parameter creator
 * @export
 */
export const MeDriveRootChildrenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/drive/root/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDriveRootChildrenApi - functional programming interface
 * @export
 */
export const MeDriveRootChildrenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDriveRootChildrenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeGetChildren(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDriveItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeGetChildren(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeDriveRootChildrenApi - factory interface
 * @export
 */
export const MeDriveRootChildrenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDriveRootChildrenApiFp(configuration)
    return {
        /**
         * 
         * @summary Get children from drive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeGetChildren(options?: any): AxiosPromise<CollectionOfDriveItems> {
            return localVarFp.homeGetChildren(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDriveRootChildrenApi - object-oriented interface
 * @export
 * @class MeDriveRootChildrenApi
 * @extends {BaseAPI}
 */
export class MeDriveRootChildrenApi extends BaseAPI {
    /**
     * 
     * @summary Get children from drive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDriveRootChildrenApi
     */
    public homeGetChildren(options?: AxiosRequestConfig) {
        return MeDriveRootChildrenApiFp(this.configuration).homeGetChildren(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeDrivesApi - axios parameter creator
 * @export
 */
export const MeDrivesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives: async ($orderby?: string, $filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeDrivesApi - functional programming interface
 * @export
 */
export const MeDrivesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeDrivesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyDrives($orderby?: string, $filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDrives>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyDrives($orderby, $filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeDrivesApi - factory interface
 * @export
 */
export const MeDrivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeDrivesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all drives where the current user is a regular member of
         * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
         * @param {string} [$filter] Filter items by property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyDrives($orderby?: string, $filter?: string, options?: any): AxiosPromise<CollectionOfDrives> {
            return localVarFp.listMyDrives($orderby, $filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeDrivesApi - object-oriented interface
 * @export
 * @class MeDrivesApi
 * @extends {BaseAPI}
 */
export class MeDrivesApi extends BaseAPI {
    /**
     * 
     * @summary Get all drives where the current user is a regular member of
     * @param {string} [$orderby] The $orderby system query option allows clients to request resources in either ascending order using asc or descending order using desc.
     * @param {string} [$filter] Filter items by property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeDrivesApi
     */
    public listMyDrives($orderby?: string, $filter?: string, options?: AxiosRequestConfig) {
        return MeDrivesApiFp(this.configuration).listMyDrives($orderby, $filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeUserApi - axios parameter creator
 * @export
 */
export const MeUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser: async ($expand?: Set<'memberOf'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeUserApi - functional programming interface
 * @export
 */
export const MeUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnUser($expand?: Set<'memberOf'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnUser($expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeUserApi - factory interface
 * @export
 */
export const MeUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user
         * @param {Set<'memberOf'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser($expand?: Set<'memberOf'>, options?: any): AxiosPromise<User> {
            return localVarFp.getOwnUser($expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeUserApi - object-oriented interface
 * @export
 * @class MeUserApi
 * @extends {BaseAPI}
 */
export class MeUserApi extends BaseAPI {
    /**
     * 
     * @summary Get current user
     * @param {Set<'memberOf'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeUserApi
     */
    public getOwnUser($expand?: Set<'memberOf'>, options?: AxiosRequestConfig) {
        return MeUserApiFp(this.configuration).getOwnUser($expand, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags: async (tagAssignment?: TagAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags: async (tagUnassignment?: TagUnassignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/org.libregraph/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUnassignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTags(tagAssignment?: TagAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTags(tagAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignTags(tagUnassignment?: TagUnassignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTags(tagUnassignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign tags to a resource
         * @param {TagAssignment} [tagAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTags(tagAssignment?: TagAssignment, options?: any): AxiosPromise<void> {
            return localVarFp.assignTags(tagAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all known tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<CollectionOfTags> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign tags from a resource
         * @param {TagUnassignment} [tagUnassignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTags(tagUnassignment?: TagUnassignment, options?: any): AxiosPromise<void> {
            return localVarFp.unassignTags(tagUnassignment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Assign tags to a resource
     * @param {TagAssignment} [tagAssignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public assignTags(tagAssignment?: TagAssignment, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).assignTags(tagAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all known tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign tags from a resource
     * @param {TagUnassignment} [tagUnassignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public unassignTags(tagUnassignment?: TagUnassignment, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).unassignTags(tagUnassignment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData: async (userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('exportPersonalData', 'userId', userId)
            const localVarPath = `/users/{user-id}/exportPersonalData`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportPersonalDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, $select?: Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPersonalData(userId, exportPersonalDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, $select?: Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from users
         * @param {string} userId key: id or name of user
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary export personal data of a user
         * @param {string} userId key: id or name of user
         * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from users by key
         * @param {string} userId key: id or name of user
         * @param {Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, $select?: Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in users
         * @param {string} userId key: id of user
         * @param {User} user New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userId, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from users
     * @param {string} userId key: id or name of user
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, ifMatch?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary export personal data of a user
     * @param {string} userId key: id or name of user
     * @param {ExportPersonalDataRequest} [exportPersonalDataRequest] destination the file should be created at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public exportPersonalData(userId: string, exportPersonalDataRequest?: ExportPersonalDataRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).exportPersonalData(userId, exportPersonalDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from users by key
     * @param {string} userId key: id or name of user
     * @param {Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
     * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, $select?: Set<'id' | 'displayName' | 'drive' | 'drives' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in users
     * @param {string} userId key: id of user
     * @param {User} user New property values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserAppRoleAssignmentApi - axios parameter creator
 * @export
 */
export const UserAppRoleAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments: async (userId: string, appRoleAssignment: AppRoleAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignment' is not null or undefined
            assertParamExists('userCreateAppRoleAssignments', 'appRoleAssignment', appRoleAssignment)
            const localVarPath = `/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appRoleAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments: async (userId: string, appRoleAssignmentId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'userId', userId)
            // verify required parameter 'appRoleAssignmentId' is not null or undefined
            assertParamExists('userDeleteAppRoleAssignments', 'appRoleAssignmentId', appRoleAssignmentId)
            const localVarPath = `/users/{user-id}/appRoleAssignments/{appRoleAssignment-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"appRoleAssignment-id"}}`, encodeURIComponent(String(appRoleAssignmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userListAppRoleAssignments', 'userId', userId)
            const localVarPath = `/users/{user-id}/appRoleAssignments`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAppRoleAssignmentApi - functional programming interface
 * @export
 */
export const UserAppRoleAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAppRoleAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppRoleAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateAppRoleAssignments(userId, appRoleAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListAppRoleAssignments(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAppRoleAssignments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListAppRoleAssignments(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserAppRoleAssignmentApi - factory interface
 * @export
 */
export const UserAppRoleAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAppRoleAssignmentApiFp(configuration)
    return {
        /**
         * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
         * @summary Grant an appRoleAssignment to a user
         * @param {string} userId key: id of user
         * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: any): AxiosPromise<AppRoleAssignment> {
            return localVarFp.userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the appRoleAssignment from a user
         * @param {string} userId key: id of user
         * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Represents the global roles a user has been granted for an application.
         * @summary Get appRoleAssignments from a user
         * @param {string} userId key: id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListAppRoleAssignments(userId: string, options?: any): AxiosPromise<CollectionOfAppRoleAssignments> {
            return localVarFp.userListAppRoleAssignments(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAppRoleAssignmentApi - object-oriented interface
 * @export
 * @class UserAppRoleAssignmentApi
 * @extends {BaseAPI}
 */
export class UserAppRoleAssignmentApi extends BaseAPI {
    /**
     * Use this API to assign a global role to a user. To grant an app role assignment to a user, you need three identifiers: * `principalId`: The `id` of the user to whom you are assigning the app role. * `resourceId`: The `id` of the resource `servicePrincipal` or `application` that has defined the app role. * `appRoleId`: The `id` of the `appRole` (defined on the resource service principal or application) to assign to the user. 
     * @summary Grant an appRoleAssignment to a user
     * @param {string} userId key: id of user
     * @param {AppRoleAssignment} appRoleAssignment New app role assignment value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userCreateAppRoleAssignments(userId: string, appRoleAssignment: AppRoleAssignment, options?: AxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userCreateAppRoleAssignments(userId, appRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the appRoleAssignment from a user
     * @param {string} userId key: id of user
     * @param {string} appRoleAssignmentId key: id of appRoleAssignment. This is the concatenated {user-id}:{appRole-id} separated by a colon.
     * @param {string} [ifMatch] ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userDeleteAppRoleAssignments(userId: string, appRoleAssignmentId: string, ifMatch?: string, options?: AxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userDeleteAppRoleAssignments(userId, appRoleAssignmentId, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Represents the global roles a user has been granted for an application.
     * @summary Get appRoleAssignments from a user
     * @param {string} userId key: id of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAppRoleAssignmentApi
     */
    public userListAppRoleAssignments(userId: string, options?: AxiosRequestConfig) {
        return UserAppRoleAssignmentApiFp(this.configuration).userListAppRoleAssignments(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async ($search?: string, $filter?: string, $orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $select?: Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers($search?: string, $filter?: string, $orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $select?: Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers($search, $filter, $orderby, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to users
         * @param {User} user New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from users
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter users by property values and relationship attributes
         * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
         * @param {Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
         * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers($search?: string, $filter?: string, $orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $select?: Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: any): AxiosPromise<CollectionOfUser> {
            return localVarFp.listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to users
     * @param {User} user New entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from users
     * @param {string} [$search] Search items by search phrases
     * @param {string} [$filter] Filter users by property values and relationship attributes
     * @param {Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>} [$orderby] Order items by property values
     * @param {Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>} [$select] Select properties to be returned
     * @param {Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>} [$expand] Expand related entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers($search?: string, $filter?: string, $orderby?: Set<'displayName' | 'displayName desc' | 'mail' | 'mail desc' | 'onPremisesSamAccountName' | 'onPremisesSamAccountName desc'>, $select?: Set<'id' | 'displayName' | 'mail' | 'memberOf' | 'onPremisesSamAccountName' | 'surname'>, $expand?: Set<'drive' | 'drives' | 'memberOf' | 'appRoleAssignments'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers($search, $filter, $orderby, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }
}


