<template>
  <div id="incoming" class="sciencemesh-app">
    <div>
      <div class="oc-flex oc-flex-middle oc-px-m oc-pt-s">
        <oc-icon name="user-received" />
        <h2 class="oc-px-s" v-text="$gettext('Accept invitations')" />
        <oc-contextual-helper class="oc-pl-xs" v-bind="helperContent" />
      </div>
      <div class="oc-flex oc-flex-column oc-flex-middle oc-flex-center oc-p-m">
        <div class="oc-width-1-2">
          <oc-text-input
            v-model="token"
            :label="$gettext('Enter invite token')"
            :clear-button-enabled="true"
            class="oc-mb-s"
            @update:model-value="decodeInviteToken"
          />
          <div
            :class="{
              'oc-text-input-danger': providerError && token,
              'oc-text-input-success': provider
            }"
          >
            <span v-text="$gettext('Institution:')" />
            <span v-if="!token" v-text="'-'" />
            <span v-else-if="provider" v-text="provider" />
            <span v-else v-text="$gettext('invalid invite token')" />
          </div>
        </div>
        <div
          v-oc-tooltip="isUsingOwnGeneratedTokenToolTip"
          :aria-label="isUsingOwnGeneratedTokenToolTip"
        >
          <oc-button
            size="small"
            :disabled="acceptInvitationButtonDisabled"
            class="oc-mt-s"
            @click="acceptInvite"
          >
            <oc-icon name="add" />
            <span v-text="$gettext('Accept invitation')" />
          </oc-button>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { computed, ref, unref } from 'vue'
import {
  useClientService,
  useRoute,
  useRouter,
  useMessages,
  useInviteTokensListStore
} from '@ownclouders/web-pkg'
import { useGettext } from 'vue3-gettext'

const emit = defineEmits<{ (e: 'highlightNewConnections'): void }>()

const { showErrorMessage } = useMessages()
const router = useRouter()
const route = useRoute()
const inviteTokensListStore = useInviteTokensListStore()
const clientService = useClientService()
const { $gettext } = useGettext()

const token = ref<string>(undefined)
const decodedToken = ref<string>(undefined)
const provider = ref<string>(undefined)
const providerError = ref(false)

const helperContent = computed(() => {
  return {
    text: $gettext(
      'Once you accept the invitation, the inviter will be added to your connections.'
    ),
    title: $gettext('Accepting invitations')
  }
})

/**
 * Check if the token is generated by the user.
 * This is to avoid accepting own generated tokens.
 * In other words, the user should not be able to accept their own invitations.
 * @param token
 *
 * @returns boolean
 */
const isOwnGeneratedToken = (token: string) => {
  return inviteTokensListStore.getTokensList().some((t) => t.token === token)
}

const isUsingOwnGeneratedTokenToolTip = computed(() =>
  isOwnGeneratedToken(unref(decodedToken)) ? $gettext('Self-invitations are not permitted') : ''
)

const acceptInvitationButtonDisabled = computed(() => {
  return !unref(decodedToken) || !unref(provider) || isOwnGeneratedToken(unref(decodedToken))
})

const errorPopup = (error: Error) => {
  console.error(error)
  showErrorMessage({
    title: $gettext('Error'),
    desc: $gettext('An error occurred'),
    errors: [error]
  })
}
const acceptInvite = async () => {
  if (isOwnGeneratedToken(unref(decodedToken))) {
    return
  }

  try {
    await clientService.httpAuthenticated.post('/sciencemesh/accept-invite', {
      token: unref(decodedToken),
      providerDomain: unref(provider)
    })
    token.value = undefined
    provider.value = undefined

    const { token: currentToken, providerDomain, ...query } = unref(route).query
    router.replace({
      name: 'open-cloud-mesh-invitations',
      query
    })

    emit('highlightNewConnections')
  } catch (error) {
    errorPopup(error)
  }
}

const decodeInviteToken = (value: string) => {
  try {
    const decoded = atob(value)
    if (!decoded.includes('@')) {
      throw new Error()
    }
    const [token, serverUrl] = decoded.split('@')
    provider.value = serverUrl
    decodedToken.value = token
    providerError.value = false
  } catch (e) {
    provider.value = ''
    decodedToken.value = ''
    providerError.value = true
  }
}
</script>

<style lang="scss">
.sciencemesh-app {
  .option {
    display: block;
  }

  .vs__selected,
  .options-wrapper {
    max-width: 100%;
  }

  .vs__selected-options {
    max-width: 100%;
    overflow: hidden;
  }
}
</style>
